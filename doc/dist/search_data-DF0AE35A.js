searchData={"items":[{"type":"module","title":"esdb_capability","doc":"Capability token creation, signing, and delegation Provides functions for creating UCAN-inspired capability tokens that grant specific permissions to specific audiences. Tokens can be delegated with attenuation (reduced permissions). Token Lifecycle 1. Create: Build a capability with issuer, audience, and grants 2. Sign: Sign with issuer's private key 3. Encode: Serialize to JWT or Erlang binary format 4. Transmit: Send with request to server 5. (Server) Verify: Check signature, expiry, revocation, permissions Delegation Tokens can be delegated to create child tokens with reduced permissions. The child token includes a proof reference to the parent token. Permissions can only be attenuated (reduced), never expanded. Example Create and sign a capability: Issuer = esdb_identity:generate(), Audience = esdb_identity:generate(), Grants = [esdb_capability:grant(Resource, Action)], Cap = esdb_capability:create(Issuer, Audience, Grants, #{ttl => 900}), SignedCap = esdb_capability:sign(Cap, esdb_identity:private_key(Issuer)), Token = esdb_capability:encode(SignedCap, jwt).","ref":"esdb_capability.html"},{"type":"function","title":"esdb_capability.attenuate/2","doc":"Check if grants are attenuated (subset of parent)","ref":"esdb_capability.html#attenuate/2"},{"type":"function","title":"esdb_capability.audience/1","doc":"Get the audience DID","ref":"esdb_capability.html#audience/1"},{"type":"type","title":"esdb_capability.capability/0","doc":"","ref":"esdb_capability.html#t:capability/0"},{"type":"type","title":"esdb_capability.capability_grant/0","doc":"","ref":"esdb_capability.html#t:capability_grant/0"},{"type":"function","title":"esdb_capability.create/3","doc":"Create a capability token with default TTL","ref":"esdb_capability.html#create/3"},{"type":"function","title":"esdb_capability.create/4","doc":"Create a capability token with options Options: - ttl: Time to live in seconds (default: 900 = 15 minutes) - nbf: Not before timestamp (default: now) - facts: Additional claims map (default: #{})","ref":"esdb_capability.html#create/4"},{"type":"function","title":"esdb_capability.decode/1","doc":"Decode a capability from either format (auto-detected)","ref":"esdb_capability.html#decode/1"},{"type":"function","title":"esdb_capability.delegate/3","doc":"Delegate a capability to a new audience with attenuated grants The new capability will include a proof reference to the parent capability. The grants must be a subset of (or equal to) the parent's grants.","ref":"esdb_capability.html#delegate/3"},{"type":"function","title":"esdb_capability.delegate/4","doc":"Delegate with options","ref":"esdb_capability.html#delegate/4"},{"type":"function","title":"esdb_capability.encode/1","doc":"Encode capability to default format (Erlang binary)","ref":"esdb_capability.html#encode/1"},{"type":"function","title":"esdb_capability.encode/2","doc":"Encode capability to specified format Formats: - binary: Erlang term_to_binary (compact, fast, BEAM-only) - jwt: JSON Web Token format (interoperable)","ref":"esdb_capability.html#encode/2"},{"type":"function","title":"esdb_capability.expires_at/1","doc":"Get the expiration timestamp","ref":"esdb_capability.html#expires_at/1"},{"type":"function","title":"esdb_capability.grant/2","doc":"Create a capability grant","ref":"esdb_capability.html#grant/2"},{"type":"function","title":"esdb_capability.grants/1","doc":"Get the capability grants","ref":"esdb_capability.html#grants/1"},{"type":"type","title":"esdb_capability.identity/0","doc":"","ref":"esdb_capability.html#t:identity/0"},{"type":"function","title":"esdb_capability.is_expired/1","doc":"Check if the capability is expired","ref":"esdb_capability.html#is_expired/1"},{"type":"function","title":"esdb_capability.issuer/1","doc":"Get the issuer DID","ref":"esdb_capability.html#issuer/1"},{"type":"function","title":"esdb_capability.proof_chain/1","doc":"Get the proof chain (parent token CIDs)","ref":"esdb_capability.html#proof_chain/1"},{"type":"function","title":"esdb_capability.sign/2","doc":"Sign a capability token with the issuer's private key","ref":"esdb_capability.html#sign/2"},{"type":"behaviour","title":"esdb_channel","doc":"Channel behavior for reckon-gater PubSub API SET Defines the behavior that all channel implementations must follow. Each channel handles a specific type of message (events, metrics, etc.) Channel priorities: - critical: alerts, security (no rate limit, HMAC required) - high: events, health - normal: metrics, system - low: logging, diagnostics","ref":"esdb_channel.html"},{"type":"function","title":"esdb_channel.behaviour_info/1","doc":"","ref":"esdb_channel.html#behaviour_info/1"},{"type":"type","title":"esdb_channel.channel_name/0","doc":"","ref":"esdb_channel.html#t:channel_name/0"},{"type":"function","title":"esdb_channel.get_subscribers/2","doc":"Get all subscribers for a topic","ref":"esdb_channel.html#get_subscribers/2"},{"type":"type","title":"esdb_channel.priority/0","doc":"","ref":"esdb_channel.html#t:priority/0"},{"type":"function","title":"esdb_channel.publish/3","doc":"Publish a message to a channel topic","ref":"esdb_channel.html#publish/3"},{"type":"function","title":"esdb_channel.publish/4","doc":"Publish with capability token for authorization","ref":"esdb_channel.html#publish/4"},{"type":"function","title":"esdb_channel.start_link/2","doc":"Start a channel","ref":"esdb_channel.html#start_link/2"},{"type":"function","title":"esdb_channel.subscribe/3","doc":"Subscribe to a channel topic","ref":"esdb_channel.html#subscribe/3"},{"type":"function","title":"esdb_channel.subscribe/4","doc":"Subscribe with capability token for authorization","ref":"esdb_channel.html#subscribe/4"},{"type":"type","title":"esdb_channel.topic/0","doc":"","ref":"esdb_channel.html#t:topic/0"},{"type":"function","title":"esdb_channel.unsubscribe/3","doc":"Unsubscribe from a channel topic","ref":"esdb_channel.html#unsubscribe/3"},{"type":"module","title":"esdb_channel_alerts","doc":"Alerts channel for reckon-gater Critical-priority channel for alert notifications. Requires HMAC signature for message authenticity. Topics: alerts.critical - Critical alerts alerts.warning - Warning alerts alerts.info - Informational alerts","ref":"esdb_channel_alerts.html"},{"type":"function","title":"esdb_channel_alerts.handle_message/2","doc":"","ref":"esdb_channel_alerts.html#handle_message/2"},{"type":"function","title":"esdb_channel_alerts.handle_publish/3","doc":"","ref":"esdb_channel_alerts.html#handle_publish/3"},{"type":"function","title":"esdb_channel_alerts.handle_subscribe/3","doc":"","ref":"esdb_channel_alerts.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_alerts.handle_unsubscribe/3","doc":"","ref":"esdb_channel_alerts.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_alerts.init/1","doc":"","ref":"esdb_channel_alerts.html#init/1"},{"type":"function","title":"esdb_channel_alerts.max_rate/0","doc":"","ref":"esdb_channel_alerts.html#max_rate/0"},{"type":"function","title":"esdb_channel_alerts.priority/0","doc":"","ref":"esdb_channel_alerts.html#priority/0"},{"type":"function","title":"esdb_channel_alerts.requires_signature/0","doc":"","ref":"esdb_channel_alerts.html#requires_signature/0"},{"type":"function","title":"esdb_channel_alerts.terminate/2","doc":"","ref":"esdb_channel_alerts.html#terminate/2"},{"type":"module","title":"esdb_channel_audit","doc":"Audit channel for reckon-gater Normal-priority channel for audit trail events. Records all significant operations for compliance. Topics: audit.store.StoreId - Store operations audit audit.user.UserId - User actions audit audit.admin - Administrative actions audit","ref":"esdb_channel_audit.html"},{"type":"function","title":"esdb_channel_audit.handle_message/2","doc":"","ref":"esdb_channel_audit.html#handle_message/2"},{"type":"function","title":"esdb_channel_audit.handle_publish/3","doc":"","ref":"esdb_channel_audit.html#handle_publish/3"},{"type":"function","title":"esdb_channel_audit.handle_subscribe/3","doc":"","ref":"esdb_channel_audit.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_audit.handle_unsubscribe/3","doc":"","ref":"esdb_channel_audit.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_audit.init/1","doc":"","ref":"esdb_channel_audit.html#init/1"},{"type":"function","title":"esdb_channel_audit.max_rate/0","doc":"","ref":"esdb_channel_audit.html#max_rate/0"},{"type":"function","title":"esdb_channel_audit.priority/0","doc":"","ref":"esdb_channel_audit.html#priority/0"},{"type":"function","title":"esdb_channel_audit.requires_signature/0","doc":"","ref":"esdb_channel_audit.html#requires_signature/0"},{"type":"function","title":"esdb_channel_audit.terminate/2","doc":"","ref":"esdb_channel_audit.html#terminate/2"},{"type":"module","title":"esdb_channel_diagnostics","doc":"Diagnostics channel for reckon-gater Low-priority channel for diagnostic information. Used for debugging and troubleshooting. Topics: diag.trace - Trace information diag.profile - Profiling data diag.debug - Debug information","ref":"esdb_channel_diagnostics.html"},{"type":"function","title":"esdb_channel_diagnostics.handle_message/2","doc":"","ref":"esdb_channel_diagnostics.html#handle_message/2"},{"type":"function","title":"esdb_channel_diagnostics.handle_publish/3","doc":"","ref":"esdb_channel_diagnostics.html#handle_publish/3"},{"type":"function","title":"esdb_channel_diagnostics.handle_subscribe/3","doc":"","ref":"esdb_channel_diagnostics.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_diagnostics.handle_unsubscribe/3","doc":"","ref":"esdb_channel_diagnostics.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_diagnostics.init/1","doc":"","ref":"esdb_channel_diagnostics.html#init/1"},{"type":"function","title":"esdb_channel_diagnostics.max_rate/0","doc":"","ref":"esdb_channel_diagnostics.html#max_rate/0"},{"type":"function","title":"esdb_channel_diagnostics.priority/0","doc":"","ref":"esdb_channel_diagnostics.html#priority/0"},{"type":"function","title":"esdb_channel_diagnostics.requires_signature/0","doc":"","ref":"esdb_channel_diagnostics.html#requires_signature/0"},{"type":"function","title":"esdb_channel_diagnostics.terminate/2","doc":"","ref":"esdb_channel_diagnostics.html#terminate/2"},{"type":"module","title":"esdb_channel_events","doc":"Events channel for reckon-gater High-priority channel for business event delivery. Events are the core of the event sourcing system. Topics: events.stream.StreamId - Events for a specific stream events.store.StoreId - All events for a store events.type.EventType - Events by type","ref":"esdb_channel_events.html"},{"type":"function","title":"esdb_channel_events.handle_message/2","doc":"","ref":"esdb_channel_events.html#handle_message/2"},{"type":"function","title":"esdb_channel_events.handle_publish/3","doc":"","ref":"esdb_channel_events.html#handle_publish/3"},{"type":"function","title":"esdb_channel_events.handle_subscribe/3","doc":"","ref":"esdb_channel_events.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_events.handle_unsubscribe/3","doc":"","ref":"esdb_channel_events.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_events.init/1","doc":"","ref":"esdb_channel_events.html#init/1"},{"type":"function","title":"esdb_channel_events.max_rate/0","doc":"","ref":"esdb_channel_events.html#max_rate/0"},{"type":"function","title":"esdb_channel_events.priority/0","doc":"","ref":"esdb_channel_events.html#priority/0"},{"type":"function","title":"esdb_channel_events.requires_signature/0","doc":"","ref":"esdb_channel_events.html#requires_signature/0"},{"type":"function","title":"esdb_channel_events.terminate/2","doc":"","ref":"esdb_channel_events.html#terminate/2"},{"type":"module","title":"esdb_channel_health","doc":"Health channel for reckon-gater High-priority channel for health status updates. Used for monitoring node and service health across the cluster. Topics: health.node.NodeName - Node health status health.store.StoreId - Store health status health.cluster - Overall cluster health","ref":"esdb_channel_health.html"},{"type":"function","title":"esdb_channel_health.handle_message/2","doc":"","ref":"esdb_channel_health.html#handle_message/2"},{"type":"function","title":"esdb_channel_health.handle_publish/3","doc":"","ref":"esdb_channel_health.html#handle_publish/3"},{"type":"function","title":"esdb_channel_health.handle_subscribe/3","doc":"","ref":"esdb_channel_health.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_health.handle_unsubscribe/3","doc":"","ref":"esdb_channel_health.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_health.init/1","doc":"","ref":"esdb_channel_health.html#init/1"},{"type":"function","title":"esdb_channel_health.max_rate/0","doc":"","ref":"esdb_channel_health.html#max_rate/0"},{"type":"function","title":"esdb_channel_health.priority/0","doc":"","ref":"esdb_channel_health.html#priority/0"},{"type":"function","title":"esdb_channel_health.requires_signature/0","doc":"","ref":"esdb_channel_health.html#requires_signature/0"},{"type":"function","title":"esdb_channel_health.terminate/2","doc":"","ref":"esdb_channel_health.html#terminate/2"},{"type":"module","title":"esdb_channel_lifecycle","doc":"Lifecycle channel for reckon-gater Normal-priority channel for lifecycle events. Tracks service and component lifecycle changes. Topics: lifecycle.store.StoreId - Store lifecycle events lifecycle.node.NodeName - Node lifecycle events lifecycle.worker - Worker lifecycle events","ref":"esdb_channel_lifecycle.html"},{"type":"function","title":"esdb_channel_lifecycle.handle_message/2","doc":"","ref":"esdb_channel_lifecycle.html#handle_message/2"},{"type":"function","title":"esdb_channel_lifecycle.handle_publish/3","doc":"","ref":"esdb_channel_lifecycle.html#handle_publish/3"},{"type":"function","title":"esdb_channel_lifecycle.handle_subscribe/3","doc":"","ref":"esdb_channel_lifecycle.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_lifecycle.handle_unsubscribe/3","doc":"","ref":"esdb_channel_lifecycle.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_lifecycle.init/1","doc":"","ref":"esdb_channel_lifecycle.html#init/1"},{"type":"function","title":"esdb_channel_lifecycle.max_rate/0","doc":"","ref":"esdb_channel_lifecycle.html#max_rate/0"},{"type":"function","title":"esdb_channel_lifecycle.priority/0","doc":"","ref":"esdb_channel_lifecycle.html#priority/0"},{"type":"function","title":"esdb_channel_lifecycle.requires_signature/0","doc":"","ref":"esdb_channel_lifecycle.html#requires_signature/0"},{"type":"function","title":"esdb_channel_lifecycle.terminate/2","doc":"","ref":"esdb_channel_lifecycle.html#terminate/2"},{"type":"module","title":"esdb_channel_logging","doc":"Logging channel for reckon-gater Low-priority channel for log message delivery. Used for centralized logging across distributed nodes. Topics: log.debug - Debug level logs log.info - Info level logs log.warning - Warning level logs log.error - Error level logs","ref":"esdb_channel_logging.html"},{"type":"function","title":"esdb_channel_logging.handle_message/2","doc":"","ref":"esdb_channel_logging.html#handle_message/2"},{"type":"function","title":"esdb_channel_logging.handle_publish/3","doc":"","ref":"esdb_channel_logging.html#handle_publish/3"},{"type":"function","title":"esdb_channel_logging.handle_subscribe/3","doc":"","ref":"esdb_channel_logging.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_logging.handle_unsubscribe/3","doc":"","ref":"esdb_channel_logging.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_logging.init/1","doc":"","ref":"esdb_channel_logging.html#init/1"},{"type":"function","title":"esdb_channel_logging.max_rate/0","doc":"","ref":"esdb_channel_logging.html#max_rate/0"},{"type":"function","title":"esdb_channel_logging.priority/0","doc":"","ref":"esdb_channel_logging.html#priority/0"},{"type":"function","title":"esdb_channel_logging.requires_signature/0","doc":"","ref":"esdb_channel_logging.html#requires_signature/0"},{"type":"function","title":"esdb_channel_logging.terminate/2","doc":"","ref":"esdb_channel_logging.html#terminate/2"},{"type":"module","title":"esdb_channel_metrics","doc":"Metrics channel for reckon-gater Normal-priority channel for metrics delivery. Used for performance monitoring and statistics. Topics: metrics.store.StoreId - Store metrics metrics.stream.StreamId - Stream metrics metrics.gateway - Gateway metrics","ref":"esdb_channel_metrics.html"},{"type":"function","title":"esdb_channel_metrics.handle_message/2","doc":"","ref":"esdb_channel_metrics.html#handle_message/2"},{"type":"function","title":"esdb_channel_metrics.handle_publish/3","doc":"","ref":"esdb_channel_metrics.html#handle_publish/3"},{"type":"function","title":"esdb_channel_metrics.handle_subscribe/3","doc":"","ref":"esdb_channel_metrics.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_metrics.handle_unsubscribe/3","doc":"","ref":"esdb_channel_metrics.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_metrics.init/1","doc":"","ref":"esdb_channel_metrics.html#init/1"},{"type":"function","title":"esdb_channel_metrics.max_rate/0","doc":"","ref":"esdb_channel_metrics.html#max_rate/0"},{"type":"function","title":"esdb_channel_metrics.priority/0","doc":"","ref":"esdb_channel_metrics.html#priority/0"},{"type":"function","title":"esdb_channel_metrics.requires_signature/0","doc":"","ref":"esdb_channel_metrics.html#requires_signature/0"},{"type":"function","title":"esdb_channel_metrics.terminate/2","doc":"","ref":"esdb_channel_metrics.html#terminate/2"},{"type":"module","title":"esdb_channel_security","doc":"Security channel for reckon-gater Critical-priority channel for security-related events. Requires HMAC signature for message authenticity. Topics: security.auth - Authentication events security.access - Access control events security.audit - Security audit events","ref":"esdb_channel_security.html"},{"type":"function","title":"esdb_channel_security.handle_message/2","doc":"","ref":"esdb_channel_security.html#handle_message/2"},{"type":"function","title":"esdb_channel_security.handle_publish/3","doc":"","ref":"esdb_channel_security.html#handle_publish/3"},{"type":"function","title":"esdb_channel_security.handle_subscribe/3","doc":"","ref":"esdb_channel_security.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_security.handle_unsubscribe/3","doc":"","ref":"esdb_channel_security.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_security.init/1","doc":"","ref":"esdb_channel_security.html#init/1"},{"type":"function","title":"esdb_channel_security.max_rate/0","doc":"","ref":"esdb_channel_security.html#max_rate/0"},{"type":"function","title":"esdb_channel_security.priority/0","doc":"","ref":"esdb_channel_security.html#priority/0"},{"type":"function","title":"esdb_channel_security.requires_signature/0","doc":"","ref":"esdb_channel_security.html#requires_signature/0"},{"type":"function","title":"esdb_channel_security.terminate/2","doc":"","ref":"esdb_channel_security.html#terminate/2"},{"type":"module","title":"esdb_channel_server","doc":"Generic channel server for reckon-gater Implements the common server logic for all channels. Delegates channel-specific behavior to the callback module. Features: - Topic-based pub/sub using pg groups - Rate limiting (configurable per channel) - HMAC signature verification (for critical channels) - Telemetry integration","ref":"esdb_channel_server.html"},{"type":"function","title":"esdb_channel_server.get_subscribers/2","doc":"","ref":"esdb_channel_server.html#get_subscribers/2"},{"type":"function","title":"esdb_channel_server.handle_call/3","doc":"","ref":"esdb_channel_server.html#handle_call/3"},{"type":"function","title":"esdb_channel_server.handle_cast/2","doc":"","ref":"esdb_channel_server.html#handle_cast/2"},{"type":"function","title":"esdb_channel_server.handle_info/2","doc":"","ref":"esdb_channel_server.html#handle_info/2"},{"type":"function","title":"esdb_channel_server.init/1","doc":"","ref":"esdb_channel_server.html#init/1"},{"type":"function","title":"esdb_channel_server.publish/3","doc":"","ref":"esdb_channel_server.html#publish/3"},{"type":"function","title":"esdb_channel_server.publish/4","doc":"Publish with capability token for authorization","ref":"esdb_channel_server.html#publish/4"},{"type":"function","title":"esdb_channel_server.start_link/2","doc":"","ref":"esdb_channel_server.html#start_link/2"},{"type":"function","title":"esdb_channel_server.subscribe/3","doc":"","ref":"esdb_channel_server.html#subscribe/3"},{"type":"function","title":"esdb_channel_server.subscribe/4","doc":"Subscribe with capability token for authorization","ref":"esdb_channel_server.html#subscribe/4"},{"type":"function","title":"esdb_channel_server.terminate/2","doc":"","ref":"esdb_channel_server.html#terminate/2"},{"type":"function","title":"esdb_channel_server.unsubscribe/3","doc":"","ref":"esdb_channel_server.html#unsubscribe/3"},{"type":"module","title":"esdb_channel_sup","doc":"Channel supervisor for reckon-gater PubSub API SET Supervises all 10 channel implementations: - esdb_channel_events (high priority) - esdb_channel_health (high priority) - esdb_channel_alerts (critical, HMAC required) - esdb_channel_security (critical, HMAC required) - esdb_channel_system (normal priority) - esdb_channel_metrics (normal priority) - esdb_channel_audit (normal priority) - esdb_channel_lifecycle (normal priority) - esdb_channel_logging (low priority) - esdb_channel_diagnostics (low priority)","ref":"esdb_channel_sup.html"},{"type":"function","title":"esdb_channel_sup.init/1","doc":"","ref":"esdb_channel_sup.html#init/1"},{"type":"function","title":"esdb_channel_sup.start_link/0","doc":"","ref":"esdb_channel_sup.html#start_link/0"},{"type":"module","title":"esdb_channel_system","doc":"System channel for reckon-gater Normal-priority channel for system-level messages. Used for internal coordination and status updates. Topics: system.status - System status updates system.config - Configuration changes system.maintenance - Maintenance notifications","ref":"esdb_channel_system.html"},{"type":"function","title":"esdb_channel_system.handle_message/2","doc":"","ref":"esdb_channel_system.html#handle_message/2"},{"type":"function","title":"esdb_channel_system.handle_publish/3","doc":"","ref":"esdb_channel_system.html#handle_publish/3"},{"type":"function","title":"esdb_channel_system.handle_subscribe/3","doc":"","ref":"esdb_channel_system.html#handle_subscribe/3"},{"type":"function","title":"esdb_channel_system.handle_unsubscribe/3","doc":"","ref":"esdb_channel_system.html#handle_unsubscribe/3"},{"type":"function","title":"esdb_channel_system.init/1","doc":"","ref":"esdb_channel_system.html#init/1"},{"type":"function","title":"esdb_channel_system.max_rate/0","doc":"","ref":"esdb_channel_system.html#max_rate/0"},{"type":"function","title":"esdb_channel_system.priority/0","doc":"","ref":"esdb_channel_system.html#priority/0"},{"type":"function","title":"esdb_channel_system.requires_signature/0","doc":"","ref":"esdb_channel_system.html#requires_signature/0"},{"type":"function","title":"esdb_channel_system.terminate/2","doc":"","ref":"esdb_channel_system.html#terminate/2"},{"type":"module","title":"esdb_gater_api","doc":"Main API for reckon-gater Provides the primary interface for accessing reckon-db event stores through the gateway with automatic load balancing and retry. This module mirrors the ExESDBGater.API pattern from the original Elixir implementation, providing specific functions for each operation rather than a generic call interface. Stream Operations {ok, Version} = esdb_gater_api:append_events(my_store, StreamId, Events). {ok, Events} = esdb_gater_api:get_events(my_store, StreamId, 0, 100, forward). {ok, Version} = esdb_gater_api:get_version(my_store, StreamId). Subscription Operations ok = esdb_gater_api:save_subscription(my_store, by_stream, Selector, Name). ok = esdb_gater_api:remove_subscription(my_store, by_stream, Selector, Name). Snapshot Operations ok = esdb_gater_api:record_snapshot(my_store, SourceId, StreamId, Version, Data). {ok, Snapshot} = esdb_gater_api:read_snapshot(my_store, SourceId, StreamId, Version).","ref":"esdb_gater_api.html"},{"type":"function","title":"esdb_gater_api.ack_event/4","doc":"Acknowledge receipt of an event by a subscriber","ref":"esdb_gater_api.html#ack_event/4"},{"type":"function","title":"esdb_gater_api.append_events/3","doc":"Append events to a stream (auto-versioned)","ref":"esdb_gater_api.html#append_events/3"},{"type":"function","title":"esdb_gater_api.append_events/4","doc":"Append events to a stream with expected version","ref":"esdb_gater_api.html#append_events/4"},{"type":"function","title":"esdb_gater_api.build_causation_graph/2","doc":"Build a causation graph for visualization","ref":"esdb_gater_api.html#build_causation_graph/2"},{"type":"function","title":"esdb_gater_api.check_raft_log_consistency/1","doc":"Check Raft log consistency for a store","ref":"esdb_gater_api.html#check_raft_log_consistency/1"},{"type":"function","title":"esdb_gater_api.create_link/2","doc":"Create a new link","ref":"esdb_gater_api.html#create_link/2"},{"type":"function","title":"esdb_gater_api.delete_link/2","doc":"Delete a link","ref":"esdb_gater_api.html#delete_link/2"},{"type":"function","title":"esdb_gater_api.delete_snapshot/4","doc":"Delete a snapshot","ref":"esdb_gater_api.html#delete_snapshot/4"},{"type":"function","title":"esdb_gater_api.delete_stream/2","doc":"Delete a stream and all its events","ref":"esdb_gater_api.html#delete_stream/2"},{"type":"function","title":"esdb_gater_api.get_causation_chain/2","doc":"Get the full causation chain for an event","ref":"esdb_gater_api.html#get_causation_chain/2"},{"type":"function","title":"esdb_gater_api.get_cause/2","doc":"Get the event that caused another","ref":"esdb_gater_api.html#get_cause/2"},{"type":"function","title":"esdb_gater_api.get_correlated/2","doc":"Get all events with the same correlation ID","ref":"esdb_gater_api.html#get_correlated/2"},{"type":"function","title":"esdb_gater_api.get_effects/2","doc":"Get events caused by an event","ref":"esdb_gater_api.html#get_effects/2"},{"type":"function","title":"esdb_gater_api.get_events/5","doc":"Get events from a stream","ref":"esdb_gater_api.html#get_events/5"},{"type":"function","title":"esdb_gater_api.get_link/2","doc":"Get a link by name","ref":"esdb_gater_api.html#get_link/2"},{"type":"function","title":"esdb_gater_api.get_memory_level/1","doc":"Get current memory pressure level","ref":"esdb_gater_api.html#get_memory_level/1"},{"type":"function","title":"esdb_gater_api.get_memory_stats/1","doc":"Get memory statistics","ref":"esdb_gater_api.html#get_memory_stats/1"},{"type":"function","title":"esdb_gater_api.get_schema/2","doc":"Get a schema by event type","ref":"esdb_gater_api.html#get_schema/2"},{"type":"function","title":"esdb_gater_api.get_schema_version/2","doc":"Get the version of a schema","ref":"esdb_gater_api.html#get_schema_version/2"},{"type":"function","title":"esdb_gater_api.get_streams/1","doc":"Get all streams in a store","ref":"esdb_gater_api.html#get_streams/1"},{"type":"function","title":"esdb_gater_api.get_subscription/2","doc":"Get a specific subscription by name Returns the subscription details including the checkpoint.","ref":"esdb_gater_api.html#get_subscription/2"},{"type":"function","title":"esdb_gater_api.get_subscriptions/1","doc":"Get all subscriptions for a store","ref":"esdb_gater_api.html#get_subscriptions/1"},{"type":"function","title":"esdb_gater_api.get_version/2","doc":"Get the current version of a stream","ref":"esdb_gater_api.html#get_version/2"},{"type":"function","title":"esdb_gater_api.get_workers/1","doc":"Get all registered workers for a store","ref":"esdb_gater_api.html#get_workers/1"},{"type":"function","title":"esdb_gater_api.health/0","doc":"Get gateway health status","ref":"esdb_gater_api.html#health/0"},{"type":"function","title":"esdb_gater_api.link_info/2","doc":"Get detailed info about a link","ref":"esdb_gater_api.html#link_info/2"},{"type":"function","title":"esdb_gater_api.list_links/1","doc":"List all links","ref":"esdb_gater_api.html#list_links/1"},{"type":"function","title":"esdb_gater_api.list_schemas/1","doc":"List all schemas","ref":"esdb_gater_api.html#list_schemas/1"},{"type":"function","title":"esdb_gater_api.list_snapshots/3","doc":"List snapshots","ref":"esdb_gater_api.html#list_snapshots/3"},{"type":"function","title":"esdb_gater_api.list_stores/0","doc":"List all managed stores in the cluster","ref":"esdb_gater_api.html#list_stores/0"},{"type":"function","title":"esdb_gater_api.quick_health_check/1","doc":"Quick health check for a store","ref":"esdb_gater_api.html#quick_health_check/1"},{"type":"function","title":"esdb_gater_api.read_by_event_types/3","doc":"Read events by type using native Khepri filtering This uses the server-side read_by_event_types which performs efficient filtering at the database level rather than loading all events.","ref":"esdb_gater_api.html#read_by_event_types/3"},{"type":"function","title":"esdb_gater_api.read_range/4","doc":"Read events in a time range","ref":"esdb_gater_api.html#read_range/4"},{"type":"function","title":"esdb_gater_api.read_range/5","doc":"Read events in a time range with options","ref":"esdb_gater_api.html#read_range/5"},{"type":"function","title":"esdb_gater_api.read_snapshot/4","doc":"Read a snapshot","ref":"esdb_gater_api.html#read_snapshot/4"},{"type":"function","title":"esdb_gater_api.read_until/3","doc":"Read events up to a timestamp","ref":"esdb_gater_api.html#read_until/3"},{"type":"function","title":"esdb_gater_api.read_until/4","doc":"Read events up to a timestamp with options","ref":"esdb_gater_api.html#read_until/4"},{"type":"function","title":"esdb_gater_api.record_snapshot/5","doc":"Record a snapshot","ref":"esdb_gater_api.html#record_snapshot/5"},{"type":"function","title":"esdb_gater_api.register_schema/3","doc":"Register a schema","ref":"esdb_gater_api.html#register_schema/3"},{"type":"function","title":"esdb_gater_api.register_worker/1","doc":"Register current process as a worker for a store","ref":"esdb_gater_api.html#register_worker/1"},{"type":"function","title":"esdb_gater_api.register_worker/2","doc":"Register a specific process as a worker for a store","ref":"esdb_gater_api.html#register_worker/2"},{"type":"function","title":"esdb_gater_api.remove_subscription/4","doc":"Remove a subscription","ref":"esdb_gater_api.html#remove_subscription/4"},{"type":"function","title":"esdb_gater_api.save_subscription/6","doc":"Save a subscription","ref":"esdb_gater_api.html#save_subscription/6"},{"type":"function","title":"esdb_gater_api.scavenge/3","doc":"Scavenge a stream (delete old events)","ref":"esdb_gater_api.html#scavenge/3"},{"type":"function","title":"esdb_gater_api.scavenge_dry_run/3","doc":"Dry-run scavenge (preview what would be deleted)","ref":"esdb_gater_api.html#scavenge_dry_run/3"},{"type":"function","title":"esdb_gater_api.scavenge_matching/3","doc":"Scavenge streams matching a pattern","ref":"esdb_gater_api.html#scavenge_matching/3"},{"type":"function","title":"esdb_gater_api.start_link/2","doc":"Start a link","ref":"esdb_gater_api.html#start_link/2"},{"type":"function","title":"esdb_gater_api.stop_link/2","doc":"Stop a link","ref":"esdb_gater_api.html#stop_link/2"},{"type":"function","title":"esdb_gater_api.stream_backward/4","doc":"Stream events backward from a version","ref":"esdb_gater_api.html#stream_backward/4"},{"type":"function","title":"esdb_gater_api.stream_forward/4","doc":"Stream events forward from a version","ref":"esdb_gater_api.html#stream_forward/4"},{"type":"function","title":"esdb_gater_api.unregister_schema/2","doc":"Unregister a schema","ref":"esdb_gater_api.html#unregister_schema/2"},{"type":"function","title":"esdb_gater_api.unregister_worker/1","doc":"Unregister current process as a worker for a store","ref":"esdb_gater_api.html#unregister_worker/1"},{"type":"function","title":"esdb_gater_api.unregister_worker/2","doc":"Unregister a specific process as a worker for a store","ref":"esdb_gater_api.html#unregister_worker/2"},{"type":"function","title":"esdb_gater_api.upcast_events/2","doc":"Upcast events to current schema version","ref":"esdb_gater_api.html#upcast_events/2"},{"type":"function","title":"esdb_gater_api.verify_cluster_consistency/1","doc":"Verify cluster consistency for a store","ref":"esdb_gater_api.html#verify_cluster_consistency/1"},{"type":"function","title":"esdb_gater_api.verify_membership_consensus/1","doc":"Verify membership consensus for a store","ref":"esdb_gater_api.html#verify_membership_consensus/1"},{"type":"function","title":"esdb_gater_api.version_at/3","doc":"Get stream version at a specific timestamp","ref":"esdb_gater_api.html#version_at/3"},{"type":"type","title":"esdb_gater_api.worker_entry/0","doc":"","ref":"esdb_gater_api.html#t:worker_entry/0"},{"type":"module","title":"esdb_gater_cluster_monitor","doc":"Cluster monitor for reckon-gater Monitors node health and manages cluster membership: - Tracks node up/down events - Emits telemetry for cluster changes - Maintains connected node list","ref":"esdb_gater_cluster_monitor.html"},{"type":"function","title":"esdb_gater_cluster_monitor.get_nodes/0","doc":"Get list of connected nodes","ref":"esdb_gater_cluster_monitor.html#get_nodes/0"},{"type":"function","title":"esdb_gater_cluster_monitor.handle_call/3","doc":"","ref":"esdb_gater_cluster_monitor.html#handle_call/3"},{"type":"function","title":"esdb_gater_cluster_monitor.handle_cast/2","doc":"","ref":"esdb_gater_cluster_monitor.html#handle_cast/2"},{"type":"function","title":"esdb_gater_cluster_monitor.handle_info/2","doc":"","ref":"esdb_gater_cluster_monitor.html#handle_info/2"},{"type":"function","title":"esdb_gater_cluster_monitor.init/1","doc":"","ref":"esdb_gater_cluster_monitor.html#init/1"},{"type":"function","title":"esdb_gater_cluster_monitor.is_healthy/0","doc":"Check if cluster is healthy","ref":"esdb_gater_cluster_monitor.html#is_healthy/0"},{"type":"function","title":"esdb_gater_cluster_monitor.start_link/0","doc":"","ref":"esdb_gater_cluster_monitor.html#start_link/0"},{"type":"function","title":"esdb_gater_cluster_monitor.terminate/2","doc":"","ref":"esdb_gater_cluster_monitor.html#terminate/2"},{"type":"module","title":"esdb_gater_cluster_sup","doc":"Cluster supervisor for reckon-gater Supervises cluster-related components: - Worker registry (Ra-based distributed registry) - Cluster monitor (node health monitoring)","ref":"esdb_gater_cluster_sup.html"},{"type":"function","title":"esdb_gater_cluster_sup.init/1","doc":"","ref":"esdb_gater_cluster_sup.html#init/1"},{"type":"function","title":"esdb_gater_cluster_sup.start_link/0","doc":"","ref":"esdb_gater_cluster_sup.html#start_link/0"},{"type":"module","title":"esdb_gater_config","doc":"Global configuration for reckon-gater Manages gateway-wide configuration including capability security modes. Capability modes: disabled - Capabilities never checked (development/testing) optional - Capabilities verified if provided, allowed if not required - Capabilities always required for protected operations Configuration is read from application environment with capability_mode set to disabled, optional, or required. Per-channel overrides take precedence. If a channel has requires_capability/0 returning true, that channel always requires capabilities regardless of the global setting.","ref":"esdb_gater_config.html"},{"type":"type","title":"esdb_gater_config.capability_mode/0","doc":"","ref":"esdb_gater_config.html#t:capability_mode/0"},{"type":"function","title":"esdb_gater_config.capability_mode/0","doc":"Get the global capability mode Defaults to  disabled  for backwards compatibility.","ref":"esdb_gater_config.html#capability_mode/0"},{"type":"function","title":"esdb_gater_config.effective_capability_mode/1","doc":"Get effective mode considering channel override If the channel explicitly requires capabilities ( ChannelOverride = true`), the mode is always `required . Otherwise the global mode applies. This implements a \"most restrictive wins\" policy: - Channel override  true  + any global mode =  required  - Channel override  false  + global mode = global mode","ref":"esdb_gater_config.html#effective_capability_mode/1"},{"type":"function","title":"esdb_gater_config.set_capability_mode/1","doc":"Set the global capability mode at runtime Use for testing or dynamic configuration.","ref":"esdb_gater_config.html#set_capability_mode/1"},{"type":"module","title":"esdb_gater_crypto_nif","doc":"NIF acceleration for cryptographic operations (Enterprise Edition) This module provides high-performance native implementations of compute-intensive cryptographic operations used in capability tokens. Community vs Enterprise Edition - Community Edition (hex.pm): NIF not available, pure Erlang fallbacks used - Enterprise Edition: Add reckon_nifs dependency for 5-10x faster NIFs The NIF is optional and auto-detected at runtime. All operations have pure Erlang fallbacks in their respective modules (esdb_identity, etc.). Enabling NIF Acceleration Add reckon_nifs to your dependencies: {reckon_nifs, \"0.1.0\"} The NIFs are automatically loaded when the reckon_nifs application starts. Functions - base58_encode/1: Base58btc encoding for DIDs (5-10x faster) - base58_decode/1: Base58btc decoding for DID parsing (5-10x faster) - match_resource_pattern/2: Resource URI pattern matching (3-5x faster)","ref":"esdb_gater_crypto_nif.html"},{"type":"function","title":"esdb_gater_crypto_nif.base58_decode/1","doc":"Decode Base58 to binary Fast native implementation of Base58 decoding for DID parsing. Falls back to esdb_identity:base58_decode/1 if NIF unavailable.","ref":"esdb_gater_crypto_nif.html#base58_decode/1"},{"type":"function","title":"esdb_gater_crypto_nif.base58_encode/1","doc":"Encode binary to Base58 (Bitcoin alphabet) Fast native implementation of Base58 encoding for DID generation. Falls back to esdb_identity:base58_encode/1 if NIF unavailable.","ref":"esdb_gater_crypto_nif.html#base58_encode/1"},{"type":"function","title":"esdb_gater_crypto_nif.is_loaded/0","doc":"Check if NIF acceleration is available Returns true if the Rust NIF is loaded, false otherwise. Use this to check before calling NIF functions directly.","ref":"esdb_gater_crypto_nif.html#is_loaded/0"},{"type":"function","title":"esdb_gater_crypto_nif.match_resource_pattern/2","doc":"Match a resource pattern against a resource URI Supports: - Exact match: Pattern equals Resource - Wildcard suffix: \"esdb://realm/*\" matches any path - Prefix match: \"esdb://realm/orders-*\" matches prefix","ref":"esdb_gater_crypto_nif.html#match_resource_pattern/2"},{"type":"module","title":"esdb_gater_repl","doc":"Interactive REPL for reckon-gater Provides an interactive shell for exploring event stores, streams, causation chains, and temporal queries. Start the REPL: <span class=\"w\">  </span><span class=\"nc\">esdb_gater_repl</span><span class=\"p\">:</span><span class=\"nf\">start</span><span class=\"p\" data-group-id=\"6328290900-1\">(</span><span class=\"p\" data-group-id=\"6328290900-1\">)</span><span class=\"p\">.</span><span class=\"w\">                </span><span class=\"c1\">%% No store selected</span><span class=\"w\">\n  </span><span class=\"nc\">esdb_gater_repl</span><span class=\"p\">:</span><span class=\"nf\">start</span><span class=\"p\" data-group-id=\"6328290900-2\">(</span><span class=\"ss\">my_store</span><span class=\"p\" data-group-id=\"6328290900-2\">)</span><span class=\"p\">.</span><span class=\"w\">        </span><span class=\"c1\">%% With store pre-selected</span> Commands: <span class=\"w\">  </span><span class=\"n\">STORE</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">stores</span><span class=\"w\">              </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"ss\">all</span><span class=\"w\"> </span><span class=\"ss\">stores</span><span class=\"w\">\n    </span><span class=\"ss\">use</span><span class=\"w\"> </span><span class=\"n\">STORE</span><span class=\"w\">           </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"ss\">current</span><span class=\"w\"> </span><span class=\"ss\">store</span><span class=\"w\"> </span><span class=\"ss\">context</span><span class=\"w\">\n \n  </span><span class=\"n\">STREAM</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">streams</span><span class=\"w\">             </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"ss\">streams</span><span class=\"w\"> </span><span class=\"ss\">in</span><span class=\"w\"> </span><span class=\"ss\">current</span><span class=\"w\"> </span><span class=\"ss\">store</span><span class=\"w\">\n    </span><span class=\"ss\">stream</span><span class=\"w\"> </span><span class=\"n\">STREAM</span><span class=\"w\">       </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"ss\">current</span><span class=\"w\"> </span><span class=\"ss\">stream</span><span class=\"w\"> </span><span class=\"ss\">context</span><span class=\"w\">\n    </span><span class=\"ss\">read</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"8432935924-1\">[</span><span class=\"n\">N</span><span class=\"p\" data-group-id=\"8432935924-1\">]</span><span class=\"w\">            </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"ss\">events</span><span class=\"w\"> </span><span class=\"ss\">from</span><span class=\"w\"> </span><span class=\"ss\">current</span><span class=\"w\"> </span><span class=\"nf\">stream</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"8432935924-2\">(</span><span class=\"ss\">default</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\" data-group-id=\"8432935924-2\">)</span><span class=\"w\">\n    </span><span class=\"ss\">read</span><span class=\"w\"> </span><span class=\"n\">STREAM</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"8432935924-3\">[</span><span class=\"n\">N</span><span class=\"p\" data-group-id=\"8432935924-3\">]</span><span class=\"w\">     </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"ss\">events</span><span class=\"w\"> </span><span class=\"ss\">from</span><span class=\"w\"> </span><span class=\"ss\">specified</span><span class=\"w\"> </span><span class=\"ss\">stream</span><span class=\"w\">\n    </span><span class=\"ss\">version</span><span class=\"w\">             </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">version</span><span class=\"w\"> </span><span class=\"k\">of</span><span class=\"w\"> </span><span class=\"ss\">current</span><span class=\"w\"> </span><span class=\"ss\">stream</span><span class=\"w\">\n    </span><span class=\"ss\">version</span><span class=\"w\"> </span><span class=\"n\">STREAM</span><span class=\"w\">      </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">version</span><span class=\"w\"> </span><span class=\"k\">of</span><span class=\"w\"> </span><span class=\"ss\">specified</span><span class=\"w\"> </span><span class=\"ss\">stream</span><span class=\"w\">\n \n  </span><span class=\"n\">CAUSATION</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">effects</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\">          </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">events</span><span class=\"w\"> </span><span class=\"ss\">caused</span><span class=\"w\"> </span><span class=\"ss\">by</span><span class=\"w\"> </span><span class=\"ss\">event</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\">\n    </span><span class=\"ss\">cause</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\">            </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">event</span><span class=\"w\"> </span><span class=\"ss\">that</span><span class=\"w\"> </span><span class=\"ss\">caused</span><span class=\"w\"> </span><span class=\"ss\">this</span><span class=\"w\"> </span><span class=\"ss\">event</span><span class=\"w\">\n    </span><span class=\"ss\">chain</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\">            </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">full</span><span class=\"w\"> </span><span class=\"ss\">causation</span><span class=\"w\"> </span><span class=\"ss\">chain</span><span class=\"w\">\n    </span><span class=\"ss\">graph</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\">            </span><span class=\"n\">Build</span><span class=\"w\"> </span><span class=\"ss\">causation</span><span class=\"w\"> </span><span class=\"ss\">graph</span><span class=\"w\">\n    </span><span class=\"ss\">dot</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"w\"> </span><span class=\"n\">FILE</span><span class=\"w\">         </span><span class=\"n\">Export</span><span class=\"w\"> </span><span class=\"ss\">causation</span><span class=\"w\"> </span><span class=\"ss\">graph</span><span class=\"w\"> </span><span class=\"ss\">as</span><span class=\"w\"> </span><span class=\"n\">DOT</span><span class=\"w\"> </span><span class=\"ss\">file</span><span class=\"w\">\n \n  </span><span class=\"n\">TEMPORAL</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">until</span><span class=\"w\"> </span><span class=\"n\">TS</span><span class=\"w\">            </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"ss\">events</span><span class=\"w\"> </span><span class=\"ss\">until</span><span class=\"w\"> </span><span class=\"ss\">timestamp</span><span class=\"w\">\n    </span><span class=\"ss\">range</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\">         </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"ss\">events</span><span class=\"w\"> </span><span class=\"ss\">in</span><span class=\"w\"> </span><span class=\"ss\">time</span><span class=\"w\"> </span><span class=\"ss\">range</span><span class=\"w\">\n \n  </span><span class=\"n\">SCHEMA</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">schemas</span><span class=\"w\">             </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"ss\">all</span><span class=\"w\"> </span><span class=\"ss\">schemas</span><span class=\"w\">\n    </span><span class=\"ss\">schema</span><span class=\"w\"> </span><span class=\"n\">TYPE</span><span class=\"w\">         </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">schema</span><span class=\"w\"> </span><span class=\"ss\">for</span><span class=\"w\"> </span><span class=\"ss\">event</span><span class=\"w\"> </span><span class=\"ss\">type</span><span class=\"w\">\n \n  </span><span class=\"n\">SUBSCRIPTION</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">subscriptions</span><span class=\"w\">       </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"ss\">all</span><span class=\"w\"> </span><span class=\"ss\">subscriptions</span><span class=\"w\">\n    </span><span class=\"ss\">subscription</span><span class=\"w\"> </span><span class=\"n\">NAME</span><span class=\"w\">   </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"ss\">subscription</span><span class=\"w\"> </span><span class=\"ss\">details</span><span class=\"w\">\n \n  </span><span class=\"n\">HEALTH</span><span class=\"w\"> </span><span class=\"n\">COMMANDS</span><span class=\"w\">\n    </span><span class=\"ss\">health</span><span class=\"w\">              </span><span class=\"n\">Gateway</span><span class=\"w\"> </span><span class=\"ss\">health</span><span class=\"w\"> </span><span class=\"ss\">status</span><span class=\"w\">\n    </span><span class=\"nb\">memory</span><span class=\"w\">              </span><span class=\"n\">Memory</span><span class=\"w\"> </span><span class=\"nb\">statistics</span><span class=\"w\">\n \n  </span><span class=\"n\">OTHER</span><span class=\"w\">\n    </span><span class=\"ss\">help</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"w\">          </span><span class=\"n\">Show</span><span class=\"w\"> </span><span class=\"ss\">help</span><span class=\"w\">\n    </span><span class=\"nb\">exit</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">quit</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">q</span><span class=\"w\">       </span><span class=\"n\">Exit</span><span class=\"w\"> </span><span class=\"n\">REPL</span>","ref":"esdb_gater_repl.html"},{"type":"function","title":"esdb_gater_repl.graph_to_dot/1","doc":"","ref":"esdb_gater_repl.html#graph_to_dot/1"},{"type":"function","title":"esdb_gater_repl.start/0","doc":"Start the REPL without a store selected","ref":"esdb_gater_repl.html#start/0"},{"type":"function","title":"esdb_gater_repl.start/1","doc":"Start the REPL with a store pre-selected","ref":"esdb_gater_repl.html#start/1"},{"type":"module","title":"esdb_gater_retry","doc":"Retry logic with exponential backoff for reckon-gater Provides configurable retry behavior with: - Exponential backoff with jitter - Maximum delay cap - Maximum retry count - Telemetry integration","ref":"esdb_gater_retry.html"},{"type":"function","title":"esdb_gater_retry.calculate_delay/2","doc":"Calculate delay for a given attempt (useful for testing)","ref":"esdb_gater_retry.html#calculate_delay/2"},{"type":"function","title":"esdb_gater_retry.default_config/0","doc":"Get default retry configuration from application environment","ref":"esdb_gater_retry.html#default_config/0"},{"type":"type","title":"esdb_gater_retry.retry_config/0","doc":"","ref":"esdb_gater_retry.html#t:retry_config/0"},{"type":"type","title":"esdb_gater_retry.retry_result/0","doc":"","ref":"esdb_gater_retry.html#t:retry_result/0"},{"type":"function","title":"esdb_gater_retry.with_retry/2","doc":"Execute a function with default retry configuration","ref":"esdb_gater_retry.html#with_retry/2"},{"type":"function","title":"esdb_gater_retry.with_retry/3","doc":"Execute a function with custom retry configuration","ref":"esdb_gater_retry.html#with_retry/3"},{"type":"module","title":"esdb_gater_telemetry","doc":"Telemetry handler for reckon-gater Provides logging handler for telemetry events and utilities for attaching/detaching handlers. Usage Attach the default logger handler: ok = esdb_gater_telemetry:attach_default_handler(). Attach a custom handler: ok = esdb_gater_telemetry:attach(my_handler, fun my_module:handle/4, #{}). Emit an event: esdb_gater_telemetry:emit(?GATER_REQUEST_STOP, #{duration => 1000}, #{store_id => my_store}).","ref":"esdb_gater_telemetry.html"},{"type":"function","title":"esdb_gater_telemetry.attach/3","doc":"Attach a custom handler for all esdb_gater events","ref":"esdb_gater_telemetry.html#attach/3"},{"type":"function","title":"esdb_gater_telemetry.attach_default_handler/0","doc":"Attach the default logger handler for all esdb_gater events","ref":"esdb_gater_telemetry.html#attach_default_handler/0"},{"type":"function","title":"esdb_gater_telemetry.detach/1","doc":"Detach a handler by ID","ref":"esdb_gater_telemetry.html#detach/1"},{"type":"function","title":"esdb_gater_telemetry.detach_default_handler/0","doc":"Detach the default logger handler","ref":"esdb_gater_telemetry.html#detach_default_handler/0"},{"type":"function","title":"esdb_gater_telemetry.emit/3","doc":"Emit a telemetry event","ref":"esdb_gater_telemetry.html#emit/3"},{"type":"function","title":"esdb_gater_telemetry.handle_event/4","doc":"Handle telemetry events (logger handler)","ref":"esdb_gater_telemetry.html#handle_event/4"},{"type":"module","title":"esdb_gater_worker_registry","doc":"pg-based distributed worker registry for reckon-gater Provides cluster-wide worker registration and discovery using Erlang's built-in pg (process groups) module. Cluster-Wide Discovery Workers registered on any node are discoverable from all nodes: -  pg:join/3` broadcasts group membership to all connected nodes - `pg:get_members/2` returns PIDs from ALL nodes in the cluster - When a node fails, pg automatically removes its members from groups == Design Rationale == This implementation uses pg instead of Ra because: 1. **Simplicity** - pg is built into OTP, no external dependencies 2. **Sufficient consistency** - Gateway worker discovery doesn t require strong consistency; finding \"any available worker\" is fine 3. **No conflicts** - Avoids Ra cluster ID conflicts with Khepri stores 4. **Automatic cleanup** - pg handles node failures automatically Eventual Consistency pg provides eventual consistency. During network partitions, different nodes may briefly see different worker lists. This is acceptable for gateway workers since: - Workers are stateless proxies to the event store - Requests are retried with exponential backoff - Any available worker can handle any request Key Features - Register gateway workers for specific stores - Cluster-wide worker discovery via pg groups - Automatic cleanup on worker death (local monitor) - Automatic cleanup on node failure (pg membership) - Load balancing via round-robin worker selection","ref":"esdb_gater_worker_registry.html"},{"type":"function","title":"esdb_gater_worker_registry.get_all_workers/0","doc":"Get all registered workers","ref":"esdb_gater_worker_registry.html#get_all_workers/0"},{"type":"function","title":"esdb_gater_worker_registry.get_workers/1","doc":"Get all workers for a store","ref":"esdb_gater_worker_registry.html#get_workers/1"},{"type":"function","title":"esdb_gater_worker_registry.handle_call/3","doc":"","ref":"esdb_gater_worker_registry.html#handle_call/3"},{"type":"function","title":"esdb_gater_worker_registry.handle_cast/2","doc":"","ref":"esdb_gater_worker_registry.html#handle_cast/2"},{"type":"function","title":"esdb_gater_worker_registry.handle_info/2","doc":"","ref":"esdb_gater_worker_registry.html#handle_info/2"},{"type":"function","title":"esdb_gater_worker_registry.init/1","doc":"","ref":"esdb_gater_worker_registry.html#init/1"},{"type":"function","title":"esdb_gater_worker_registry.register_worker/2","doc":"Register a worker for a store","ref":"esdb_gater_worker_registry.html#register_worker/2"},{"type":"function","title":"esdb_gater_worker_registry.start_link/0","doc":"","ref":"esdb_gater_worker_registry.html#start_link/0"},{"type":"function","title":"esdb_gater_worker_registry.terminate/2","doc":"","ref":"esdb_gater_worker_registry.html#terminate/2"},{"type":"function","title":"esdb_gater_worker_registry.unregister_worker/2","doc":"Unregister a worker for a store","ref":"esdb_gater_worker_registry.html#unregister_worker/2"},{"type":"type","title":"esdb_gater_worker_registry.worker_entry/0","doc":"","ref":"esdb_gater_worker_registry.html#t:worker_entry/0"},{"type":"module","title":"esdb_identity","doc":"Identity management for capability-based security Provides Ed25519 keypair generation and DID (Decentralized Identifier) encoding/decoding using the did:key method. DID Key Method DIDs are encoded as: did:key:z{base58btc(multicodec_prefix + public_key)} For Ed25519: multicodec prefix is 0xed01 NIF Acceleration Base58 encoding/decoding can be accelerated via optional Rust NIFs. When the NIF is available (Enterprise Edition), operations are 5-10x faster. Pure Erlang fallbacks are always available (Community Edition). Example Generate new identity and get DID: Identity = esdb_identity:generate(), DID = esdb_identity:did(Identity), {ok, PubKey} = esdb_identity:public_key_from_did(DID).","ref":"esdb_identity.html"},{"type":"function","title":"esdb_identity.base58_decode/1","doc":"Decode Base58 to binary Uses NIF acceleration when available, otherwise pure Erlang.","ref":"esdb_identity.html#base58_decode/1"},{"type":"function","title":"esdb_identity.base58_encode/1","doc":"Encode binary to Base58 (Bitcoin alphabet) Uses NIF acceleration when available, otherwise pure Erlang.","ref":"esdb_identity.html#base58_encode/1"},{"type":"function","title":"esdb_identity.did/1","doc":"Get the DID from an identity","ref":"esdb_identity.html#did/1"},{"type":"function","title":"esdb_identity.from_keypair/2","doc":"Create an identity from an existing Ed25519 keypair","ref":"esdb_identity.html#from_keypair/2"},{"type":"function","title":"esdb_identity.from_public_key/1","doc":"Create an identity from a public key only (for verification)","ref":"esdb_identity.html#from_public_key/1"},{"type":"function","title":"esdb_identity.generate/0","doc":"Generate a new Ed25519 identity with random keypair","ref":"esdb_identity.html#generate/0"},{"type":"type","title":"esdb_identity.identity/0","doc":"","ref":"esdb_identity.html#t:identity/0"},{"type":"function","title":"esdb_identity.is_nif_available/0","doc":"Check if NIF acceleration is available Returns true if the Rust NIF is loaded and functional. When false, pure Erlang implementations are used.","ref":"esdb_identity.html#is_nif_available/0"},{"type":"function","title":"esdb_identity.is_valid_did/1","doc":"Check if a binary is a valid did:key DID","ref":"esdb_identity.html#is_valid_did/1"},{"type":"function","title":"esdb_identity.private_key/1","doc":"Get the private key from an identity (may be undefined)","ref":"esdb_identity.html#private_key/1"},{"type":"function","title":"esdb_identity.public_key/1","doc":"Get the public key from an identity","ref":"esdb_identity.html#public_key/1"},{"type":"function","title":"esdb_identity.public_key_from_did/1","doc":"Extract public key from a did:key DID","ref":"esdb_identity.html#public_key_from_did/1"},{"type":"module","title":"esdb_pubsub_security","doc":"HMAC security utilities for reckon-gater PubSub Provides message signing and verification for critical channels. Uses HMAC-SHA256 for message authentication. Usage Sign a message: SignedMsg = esdb_pubsub_security:sign(Message). Verify a signed message: ok = esdb_pubsub_security:verify(SignedMsg). Verify with explicit secret: ok = esdb_pubsub_security:verify(SignedMsg, Secret).","ref":"esdb_pubsub_security.html"},{"type":"function","title":"esdb_pubsub_security.get_secret/0","doc":"Get the configured HMAC secret","ref":"esdb_pubsub_security.html#get_secret/0"},{"type":"function","title":"esdb_pubsub_security.set_secret/1","doc":"Set the HMAC secret","ref":"esdb_pubsub_security.html#set_secret/1"},{"type":"function","title":"esdb_pubsub_security.sign/1","doc":"Sign a message map using the configured secret","ref":"esdb_pubsub_security.html#sign/1"},{"type":"function","title":"esdb_pubsub_security.sign/2","doc":"Sign a message map using a specific secret","ref":"esdb_pubsub_security.html#sign/2"},{"type":"function","title":"esdb_pubsub_security.verify/1","doc":"Verify a signed message using the configured secret","ref":"esdb_pubsub_security.html#verify/1"},{"type":"function","title":"esdb_pubsub_security.verify/2","doc":"Verify a signed message using a specific secret","ref":"esdb_pubsub_security.html#verify/2"},{"type":"module","title":"reckon_gater_app","doc":"Application module for reckon-gater The gateway provides distributed worker registration and load balancing for reckon-db event stores.","ref":"reckon_gater_app.html"},{"type":"function","title":"reckon_gater_app.start/2","doc":"","ref":"reckon_gater_app.html#start/2"},{"type":"function","title":"reckon_gater_app.stop/1","doc":"","ref":"reckon_gater_app.html#stop/1"},{"type":"module","title":"reckon_gater_sup","doc":"Top-level supervisor for reckon-gater Supervision Tree reckon_gater_sup (one_for_one) - esdb_gater_cluster_sup (rest_for_one) - esdb_gater_worker_registry - esdb_gater_cluster_monitor - esdb_channel_sup (one_for_one) - 10x channel workers Note: esdb_gater_api is a stateless API module, not a supervised process.","ref":"reckon_gater_sup.html"},{"type":"function","title":"reckon_gater_sup.init/1","doc":"","ref":"reckon_gater_sup.html#init/1"},{"type":"function","title":"reckon_gater_sup.start_link/0","doc":"","ref":"reckon_gater_sup.html#start_link/0"},{"type":"extras","title":"Readme","doc":"# reckon-gater\n\n[![Hex.pm](https://img.shields.io/hexpm/v/reckon_gater.svg)](https://hex.pm/packages/reckon_gater)\n[![Hexdocs.pm](https://img.shields.io/badge/docs-hexdocs-blue.svg)](https://hexdocs.pm/reckon_gater)\n\nGateway for distributed access to [reckon-db](https://github.com/reckon-db-org/reckon-db) event stores.\n\n![Gateway Architecture](assets/gateway_architecture.svg)","ref":"readme.html"},{"type":"extras","title":"Overview - Readme","doc":"reckon-gater is an Erlang gateway service providing:\n\n- **Distributed Worker Registry**: pg-based registry for cluster-wide worker discovery\n- **Load Balancing**: Round-robin with exponential backoff retry\n- **Shared Type Definitions**: Common records for events, snapshots, and subscriptions\n- **Capability-Based Security**: UCAN-inspired tokens for decentralized authorization\n- **PubSub Channels**: 10 dedicated channels with priority-based delivery\n- **HMAC Security**: Message signing for critical channels\n- **Telemetry**: BEAM telemetry with optional OpenTelemetry exporters","ref":"readme.html#overview"},{"type":"extras","title":"Installation - Readme","doc":"Add to your `rebar.config`:\n\n```erlang\n{deps, [\n    {reckon_gater, \"1.0.0\"}\n]}.\n```\n\nPure Erlang implementation - works everywhere, no native dependencies.","ref":"readme.html#installation"},{"type":"extras","title":"Quick Start - Readme","doc":"```erlang\n%% Start the application (typically started by reckon-db)\napplication:ensure_all_started(reckon_gater).\n\n%% Append events to a stream\nEvents = [#{type => <<\"user_created\">>, data => #{name => <<\"Alice\">>}}],\n{ok, Version} = esdb_gater_api:append_events(my_store, <<\"users-123\">>, Events).\n\n%% Read events from a stream\n{ok, EventList} = esdb_gater_api:stream_forward(my_store, <<\"users-123\">>, 0, 100).\n\n%% Subscribe to PubSub channel\nok = esdb_channel_server:subscribe(esdb_channel_events, <<\"user.*\">>, self()).\n\n%% Receive channel messages\nreceive\n    {channel_message, esdb_channel_events, _Topic, Event} ->\n        handle_event(Event)\nend.\n```","ref":"readme.html#quick-start"},{"type":"extras","title":"API Reference - Readme","doc":"","ref":"readme.html#api-reference"},{"type":"extras","title":"Stream Operations - Readme","doc":"```erlang\n%% Append events to a stream\nesdb_gater_api:append_events(StoreId, StreamId, Events) ->\n    {ok, NewVersion} | {error, term()}.\nesdb_gater_api:append_events(StoreId, StreamId, ExpectedVersion, Events) ->\n    {ok, NewVersion} | {error, term()}.\n\n%% Read events from a stream\nesdb_gater_api:get_events(StoreId, StreamId, StartVersion, Count, Direction) ->\n    {ok, [Event]} | {error, term()}.\nesdb_gater_api:stream_forward(StoreId, StreamId, StartVersion, Count) ->\n    {ok, [Event]} | {error, term()}.\nesdb_gater_api:stream_backward(StoreId, StreamId, StartVersion, Count) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Stream metadata\nesdb_gater_api:get_version(StoreId, StreamId) -> {ok, Version} | {error, term()}.\nesdb_gater_api:stream_exists(StoreId, StreamId) -> boolean().\nesdb_gater_api:get_streams(StoreId) -> {ok, [StreamId]} | {error, term()}.\n```","ref":"readme.html#stream-operations"},{"type":"extras","title":"Subscription Operations - Readme","doc":"```erlang\n%% Create a subscription\nesdb_gater_api:save_subscription(StoreId, Type, Selector, Name, StartFrom, Subscriber) ->\n    ok | {error, term()}.\n\n%% Remove a subscription\nesdb_gater_api:remove_subscription(StoreId, Type, Selector, Name) ->\n    ok | {error, term()}.\n\n%% Acknowledge event processing\nesdb_gater_api:ack_event(StoreId, StreamId, SubscriptionName, EventNumber) ->\n    ok | {error, term()}.\n\n%% List subscriptions\nesdb_gater_api:get_subscriptions(StoreId) -> {ok, [Subscription]} | {error, term()}.\n```","ref":"readme.html#subscription-operations"},{"type":"extras","title":"Snapshot Operations - Readme","doc":"```erlang\n%% Record a snapshot\nesdb_gater_api:record_snapshot(StoreId, SourceUuid, StreamUuid, Version, Record) ->\n    ok | {error, term()}.\n\n%% Read a snapshot\nesdb_gater_api:read_snapshot(StoreId, SourceUuid, StreamUuid, Version) ->\n    {ok, Snapshot} | {error, term()}.\n\n%% Delete a snapshot\nesdb_gater_api:delete_snapshot(StoreId, SourceUuid, StreamUuid, Version) ->\n    ok | {error, term()}.\n\n%% List snapshots\nesdb_gater_api:list_snapshots(StoreId, SourceUuid, StreamUuid) ->\n    {ok, [Snapshot]} | {error, term()}.\n```","ref":"readme.html#snapshot-operations"},{"type":"extras","title":"Health - Readme","doc":"```erlang\nesdb_gater_api:health() -> healthy | {degraded, Reason} | {unhealthy, Reason}.\nesdb_gater_api:quick_health_check(StoreId) -> ok | {error, term()}.\n```","ref":"readme.html#health"},{"type":"extras","title":"Temporal Queries - Readme","doc":"Query events by timestamp for point-in-time reconstruction. See [Temporal Queries Guide](guides/temporal_queries.md).\n\n```erlang\n%% Read events up to a timestamp\nesdb_gater_api:read_until(StoreId, StreamId, Timestamp) ->\n    {ok, [Event]} | {error, term()}.\nesdb_gater_api:read_until(StoreId, StreamId, Timestamp, Opts) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Read events in a time range\nesdb_gater_api:read_range(StoreId, StreamId, FromTs, ToTs) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Get stream version at a specific timestamp\nesdb_gater_api:version_at(StoreId, StreamId, Timestamp) ->\n    {ok, Version} | {error, term()}.\n```","ref":"readme.html#temporal-queries"},{"type":"extras","title":"Scavenging - Readme","doc":"Remove old events beyond retention, optionally archive first. See [Scavenging Guide](guides/scavenging.md).\n\n```erlang\n%% Scavenge a stream (delete old events)\nesdb_gater_api:scavenge(StoreId, StreamId, Opts) ->\n    {ok, Result} | {error, term()}.\n\n%% Scavenge streams matching a pattern\nesdb_gater_api:scavenge_matching(StoreId, Pattern, Opts) ->\n    {ok, [Result]} | {error, term()}.\n\n%% Preview what would be deleted (dry run)\nesdb_gater_api:scavenge_dry_run(StoreId, StreamId, Opts) ->\n    {ok, Preview} | {error, term()}.\n```","ref":"readme.html#scavenging"},{"type":"extras","title":"Causation Tracking - Readme","doc":"Track event lineage for debugging and auditing. See [Causation Guide](guides/causation.md).\n\n![Causation Graph](assets/causation_graph.svg)\n\n```erlang\n%% Get events caused by an event\nesdb_gater_api:get_effects(StoreId, EventId) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Get the event that caused this one\nesdb_gater_api:get_cause(StoreId, EventId) ->\n    {ok, Event} | {error, not_found}.\n\n%% Get full causation chain (root to this event)\nesdb_gater_api:get_causation_chain(StoreId, EventId) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Get all events with the same correlation ID\nesdb_gater_api:get_correlated(StoreId, CorrelationId) ->\n    {ok, [Event]} | {error, term()}.\n\n%% Build causation graph for visualization\nesdb_gater_api:build_causation_graph(StoreId, EventId) ->\n    {ok, Graph} | {error, term()}.\n```","ref":"readme.html#causation-tracking"},{"type":"extras","title":"Schema Operations - Readme","doc":"Schema registry with automatic upcasting. See [Schema Evolution Guide](guides/schema_evolution.md).\n\n![Schema Upcasting](assets/schema_upcasting.svg)\n\n```erlang\n%% Register a schema\nesdb_gater_api:register_schema(StoreId, EventType, Schema) -> ok.\n\n%% Get schema for an event type\nesdb_gater_api:get_schema(StoreId, EventType) ->\n    {ok, Schema} | {error, not_found}.\n\n%% List all schemas\nesdb_gater_api:list_schemas(StoreId) -> {ok, [SchemaInfo]}.\n\n%% Upcast events to current schema version\nesdb_gater_api:upcast_events(StoreId, Events) ->\n    {ok, UpcastedEvents} | {error, term()}.\n\n%% Unregister a schema\nesdb_gater_api:unregister_schema(StoreId, EventType) -> ok.\n```","ref":"readme.html#schema-operations"},{"type":"extras","title":"Memory Pressure - Readme","doc":"Adaptive behavior based on system memory. See [Memory Pressure Guide](guides/memory_pressure.md).\n\n```erlang\n%% Get current memory pressure level\nesdb_gater_api:get_memory_level(StoreId) ->\n    {ok, normal | elevated | critical}.\n\n%% Get detailed memory statistics\nesdb_gater_api:get_memory_stats(StoreId) ->\n    {ok, #{used := bytes(), total := bytes(), level := atom()}}.\n```","ref":"readme.html#memory-pressure"},{"type":"extras","title":"Stream Links - Readme","doc":"Create derived streams from source streams. See [Stream Links Guide](guides/stream_links.md).\n\n![Stream Links](assets/stream_links.svg)\n\n```erlang\n%% Create a new link (filter + transform)\nesdb_gater_api:create_link(StoreId, LinkSpec) -> ok.\n\n%% Delete a link\nesdb_gater_api:delete_link(StoreId, LinkName) -> ok.\n\n%% Get link by name\nesdb_gater_api:get_link(StoreId, LinkName) ->\n    {ok, LinkInfo} | {error, not_found}.\n\n%% List all links\nesdb_gater_api:list_links(StoreId) -> {ok, [LinkInfo]}.\n\n%% Start/stop a link\nesdb_gater_api:start_link(StoreId, LinkName) -> ok.\nesdb_gater_api:stop_link(StoreId, LinkName) -> ok.\n\n%% Get detailed link info\nesdb_gater_api:link_info(StoreId, LinkName) ->\n    {ok, #{status := atom(), events_processed := integer()}}.\n```","ref":"readme.html#stream-links"},{"type":"extras","title":"Channels - Readme","doc":"```erlang\n%% Subscribe to a topic\nesdb_channel_server:subscribe(ChannelName, Topic, Pid) -> ok.\n\n%% Subscribe with capability token (for authorization)\nesdb_channel_server:subscribe(ChannelName, Topic, Pid, CapabilityToken) ->\n    ok | {error, {unauthorized, Reason}}.\n\n%% Unsubscribe from a topic\nesdb_channel_server:unsubscribe(ChannelName, Topic, Pid) -> ok.\n\n%% Publish a message\nesdb_channel_server:publish(ChannelName, Topic, Message) ->\n    ok | {error, rate_limited | signature_required | invalid_signature}.\n\n%% Publish with capability token (for authorization)\nesdb_channel_server:publish(ChannelName, Topic, Message, CapabilityToken) ->\n    ok | {error, {unauthorized, Reason}}.\n```","ref":"readme.html#channels"},{"type":"extras","title":"Security - Readme","doc":"```erlang\n%% Sign a message with default secret\nesdb_pubsub_security:sign(Message) -> SignedMessage.\n\n%% Sign with custom secret\nesdb_pubsub_security:sign(Message, Secret) -> SignedMessage.\n\n%% Verify a signed message\nesdb_pubsub_security:verify(SignedMessage) -> ok | {error, Reason}.\n\n%% Set the default secret\nesdb_pubsub_security:set_secret(Secret) -> ok.\n```","ref":"readme.html#security"},{"type":"extras","title":"Retry Configuration - Readme","doc":"```erlang\n%% Create custom retry config\nConfig = esdb_gater_retry:new_config(\n    100,     %% base_delay_ms\n    5000,    %% max_delay_ms\n    5        %% max_attempts\n),\n\n%% Execute with custom retry\nesdb_gater_api:execute(my_store, Fun, Config).\n```","ref":"readme.html#retry-configuration"},{"type":"extras","title":"Channels - Readme","doc":"![PubSub Channels](assets/channels.svg)\n\nThe gateway provides 10 dedicated PubSub channels:\n\n| Channel | Priority | Rate Limit | HMAC | Purpose |\n|---------|----------|------------|------|---------|\n| `esdb_channel_alerts` | critical | unlimited | required | Critical system alerts |\n| `esdb_channel_security` | critical | unlimited | required | Security events |\n| `esdb_channel_events` | high | unlimited | optional | Business events |\n| `esdb_channel_health` | high | 100/sec | optional | Health checks |\n| `esdb_channel_system` | normal | unlimited | optional | System notifications |\n| `esdb_channel_metrics` | normal | 10000/sec | optional | Performance metrics |\n| `esdb_channel_audit` | normal | unlimited | optional | Audit trail |\n| `esdb_channel_lifecycle` | normal | unlimited | optional | Lifecycle events |\n| `esdb_channel_logging` | low | 1000/sec | optional | Log messages |\n| `esdb_channel_diagnostics` | low | 100/sec | optional | Diagnostic info |","ref":"readme.html#channels-1"},{"type":"extras","title":"Channel Priorities - Readme","doc":"- **critical**: Immediate delivery, no rate limiting, HMAC required\n- **high**: Priority delivery, minimal rate limiting\n- **normal**: Standard delivery\n- **low**: Background delivery, may be rate limited","ref":"readme.html#channel-priorities"},{"type":"extras","title":"Architecture - Readme","doc":"","ref":"readme.html#architecture"},{"type":"extras","title":"Supervision Tree - Readme","doc":"![Supervision Tree](assets/supervision_tree.svg)","ref":"readme.html#supervision-tree"},{"type":"extras","title":"Worker Registry Flow - Readme","doc":"![Worker Registry Flow](assets/worker_registry_flow.svg)","ref":"readme.html#worker-registry-flow"},{"type":"extras","title":"Channel Message Flow - Readme","doc":"![Channel Message Flow](assets/channel_message_flow.svg)","ref":"readme.html#channel-message-flow"},{"type":"extras","title":"Configuration - Readme","doc":"```erlang\n%% sys.config\n[{reckon_gater, [\n    %% Cluster configuration\n    {cluster, [\n        {port, 45893},\n        {multicast_addr, {239, 255, 0, 2}}\n    ]},\n\n    %% Retry defaults\n    {retry, [\n        {base_delay_ms, 100},\n        {max_delay_ms, 30000},\n        {max_attempts, 10}\n    ]},\n\n    %% Channel configuration\n    {channels, [\n        {esdb_channel_events, [\n            {priority, high}\n        ]},\n        {esdb_channel_metrics, [\n            {max_rate, 10000}\n        ]}\n    ]},\n\n    %% Security\n    {security, [\n        {hmac_secret, <<\"your_secret_here\">>},\n        {message_ttl_seconds, 300}\n    ]},\n\n    %% Telemetry\n    {telemetry_handlers, [logger]}\n]}].\n```","ref":"readme.html#configuration"},{"type":"extras","title":"Telemetry Events - Readme","doc":"| Event | Measurements | Metadata |\n|-------|--------------|----------|\n| `[esdb_gater, worker, registered]` | system_time | store_id, node, pid |\n| `[esdb_gater, worker, unregistered]` | system_time | store_id, pid |\n| `[esdb_gater, worker, lookup]` | duration | store_id |\n| `[esdb_gater, request, start]` | system_time | store_id, request_type |\n| `[esdb_gater, request, stop]` | duration | store_id, request_type, result |\n| `[esdb_gater, request, error]` | duration | store_id, request_type, reason |\n| `[esdb_gater, retry, attempt]` | delay_ms, attempt | store_id, reason |\n| `[esdb_gater, retry, exhausted]` | total_attempts | store_id, reason |\n| `[esdb_gater, cluster, node, up]` | system_time | node, member_count |\n| `[esdb_gater, cluster, node, down]` | system_time | node, member_count |\n| `[esdb_gater, channel, broadcast]` | recipient_count | channel, topic |","ref":"readme.html#telemetry-events"},{"type":"extras","title":"Attaching Handlers - Readme","doc":"```erlang\n%% Attach default logger handler\nok = esdb_gater_telemetry:attach_default_handler().\n\n%% Attach custom handler\nHandler = fun(Event, Measurements, Meta, Config) ->\n    %% Your custom handling\n    ok\nend,\nok = esdb_gater_telemetry:attach(my_handler, Handler, #{}).\n\n%% Detach handler\nok = esdb_gater_telemetry:detach(my_handler).\n```","ref":"readme.html#attaching-handlers"},{"type":"extras","title":"Building - Readme","doc":"```bash\nrebar3 compile         # Compile\nrebar3 eunit           # Unit tests (44 tests)\nrebar3 ct              # Integration tests (8 tests)\nrebar3 dialyzer        # Type checking\n```","ref":"readme.html#building"},{"type":"extras","title":"Testing - Readme","doc":"Test counts:\n- **Unit tests**: 44 tests (retry, security, telemetry)\n- **Integration tests**: 8 tests (channel system)\n- **End-to-end tests**: 24 tests (with reckon-db, run from reckon-db)\n\n```bash\nrebar3 eunit                                    # All unit tests\nrebar3 ct --suite=esdb_channel_SUITE            # Channel tests\n```\n\nRun e2e tests from reckon-db:\n```bash\ncd /path/to/reckon-db\nrebar3 ct --suite=test/e2e/reckon_gater_e2e_SUITE\n```","ref":"readme.html#testing"},{"type":"extras","title":"Integration with reckon-db - Readme","doc":"reckon-gater is designed to work with [reckon-db](https://github.com/reckon-db-org/reckon-db) to provide load-balanced, distributed access to event stores.","ref":"readme.html#integration-with-reckon-db"},{"type":"extras","title":"Automatic Worker Registration - Readme","doc":"When both packages are deployed on the same nodes:\n\n1. **reckon-db** gateway workers automatically register with **reckon-gater**\n2. No manual registration is required\n3. Worker cleanup is automatic when nodes leave or workers crash\n\n![Automatic Worker Registration](assets/worker_registration.svg)","ref":"readme.html#automatic-worker-registration"},{"type":"extras","title":"Accessing the Event Store - Readme","doc":"Use the gateway API to access reckon-db with automatic load balancing and retry:\n\n```erlang\n%% Stream operations\n{ok, Version} = esdb_gater_api:append_events(my_store, StreamId, Events).\n{ok, Version} = esdb_gater_api:append_events(my_store, StreamId, ExpectedVersion, Events).\n{ok, Events} = esdb_gater_api:stream_forward(my_store, StreamId, 0, 100).\n{ok, Events} = esdb_gater_api:stream_backward(my_store, StreamId, 100, 50).\n{ok, Version} = esdb_gater_api:get_version(my_store, StreamId).\ntrue = esdb_gater_api:stream_exists(my_store, StreamId).\n\n%% Subscription operations\nok = esdb_gater_api:save_subscription(my_store, stream, StreamId, <<\"my_sub\">>, 0, self()).\nok = esdb_gater_api:remove_subscription(my_store, stream, StreamId, <<\"my_sub\">>).\nok = esdb_gater_api:ack_event(my_store, StreamId, <<\"my_sub\">>, EventNumber).\n{ok, Subs} = esdb_gater_api:get_subscriptions(my_store).\n\n%% Snapshot operations\nok = esdb_gater_api:record_snapshot(my_store, SourceUuid, StreamUuid, Version, Record).\n{ok, Snap} = esdb_gater_api:read_snapshot(my_store, SourceUuid, StreamUuid, Version).\nok = esdb_gater_api:delete_snapshot(my_store, SourceUuid, StreamUuid, Version).\n{ok, Snaps} = esdb_gater_api:list_snapshots(my_store, SourceUuid, StreamUuid).\n\n%% Health check\nhealthy = esdb_gater_api:health().\nok = esdb_gater_api:quick_health_check(my_store).\n```","ref":"readme.html#accessing-the-event-store"},{"type":"extras","title":"Deployment - Readme","doc":"reckon-db includes reckon-gater as a dependency. Starting reckon-db automatically starts the gateway:\n\n```erlang\n%% Start reckon-db (includes gater)\napplication:ensure_all_started(reckon_db).\n\n%% Gateway workers auto-register with the pg-based registry\n%% Use the gater API for all operations\n{ok, Version} = esdb_gater_api:append_events(my_store, StreamId, Events).\n```\n\nIn a multi-node cluster, each node runs reckon-db with its gateway worker. The pg-based registry provides:\n- Cluster-wide worker discovery via `pg:get_members/2`\n- Eventual consistency (workers visible across all nodes)\n- Automatic cleanup on node failure (pg membership)\n- Load balancing with round-robin selection\n- Exponential backoff retry on failures","ref":"readme.html#deployment"},{"type":"extras","title":"Shared Types - Readme","doc":"reckon-gater provides shared type definitions used across the ecosystem. Include them in your modules:\n\n```erlang\n-include_lib(\"reckon_gater/include/esdb_gater_types.hrl\").\n```","ref":"readme.html#shared-types"},{"type":"extras","title":"Records - Readme","doc":"| Record | Purpose |\n|--------|---------|\n| `#event{}` | Event with type, data (Erlang term), and metadata |\n| `#snapshot{}` | Aggregate snapshot at a specific version |\n| `#subscription{}` | Subscription state and configuration |\n| `#append_result{}` | Result of an append operation |","ref":"readme.html#records"},{"type":"extras","title":"Version Constants - Readme","doc":"| Constant | Value | Purpose |\n|----------|-------|---------|\n| `?NO_STREAM` | -1 | Stream must not exist (first write) |\n| `?ANY_VERSION` | -2 | No version check, always append |\n| `?STREAM_EXISTS` | -4 | Stream must exist |\n\nSee the [Shared Types Guide](guides/shared_types.md) for detailed usage.","ref":"readme.html#version-constants"},{"type":"extras","title":"Related Projects - Readme","doc":"![Ecosystem](assets/ecosystem.svg)\n\n| Project | Description |\n|---------|-------------|\n| [reckon-db](https://github.com/reckon-db-org/reckon-db) | Core event store built on Khepri/Ra |\n| [evoq](https://github.com/reckon-db-org/evoq) | CQRS/Event Sourcing framework |\n| [reckon-evoq](https://github.com/reckon-db-org/reckon-evoq) | Adapter connecting evoq to reckon-db |","ref":"readme.html#related-projects"},{"type":"extras","title":"License - Readme","doc":"Apache-2.0","ref":"readme.html#license"},{"type":"extras","title":"License","doc":"Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.","ref":"license.html"},{"type":"extras","title":"Changelog","doc":"# Changelog\n\nAll notable changes to reckon-gater will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2026-01-03","ref":"changelog.html"},{"type":"extras","title":"Changed - Changelog","doc":"- **Stable Release**: First stable release of reckon-gater under reckon-db-org\n- All APIs considered stable and ready for production use\n- Updated ecosystem.svg with correct package names (evoq, reckon-evoq)\n\n## [0.6.6] - 2025-12-26","ref":"changelog.html#changed"},{"type":"extras","title":"Fixed - Changelog","doc":"- **Duplicate module conflict**: Renamed `esdb_crypto_nif` module to\n  `esdb_gater_crypto_nif` to avoid collision with reckon_db's module of the\n  same name. This fixes Mix release errors when both packages are used together.\n\n## [0.6.5] - 2025-12-26","ref":"changelog.html#fixed"},{"type":"extras","title":"Fixed - Changelog","doc":"- **Stale rebar.lock**: Removed stale `ra` dependency from lock file that was\n  causing conflicts with reckon_db. The gateway doesn't use ra directly.\n\n## [0.6.4] - 2025-12-22","ref":"changelog.html#fixed-1"},{"type":"extras","title":"Added - Changelog","doc":"- **Configuration Guide**: Comprehensive configuration documentation\n  - All application environment options documented\n  - Erlang (sys.config) and Elixir (config.exs) examples\n  - Capability mode configuration examples\n  - Retry configuration examples\n  - Complete development/staging/production examples\n\n## [0.6.3] - 2025-12-22","ref":"changelog.html#added"},{"type":"extras","title":"Added - Changelog","doc":"- **Capability Opt-In Mode**: Global configuration for capability enforcement\n  - `esdb_gater_config:capability_mode/0` - Get current mode (disabled|optional|required)\n  - `esdb_gater_config:set_capability_mode/1` - Set mode at runtime\n  - `esdb_gater_config:effective_capability_mode/1` - Get mode with channel override\n  - Configurable via sys.config: `{capability_mode, disabled | optional | required}`\n  - Per-channel override still takes precedence (most restrictive wins)\n\n- **Interactive REPL**: Full-featured shell for event store exploration\n  - `esdb_gater_repl:start/0,1` - Start interactive shell\n  - Store commands: `stores`, `use STORE`\n  - Stream commands: `streams`, `stream STREAM`, `read`, `version`\n  - Causation commands: `effects`, `cause`, `chain`, `graph`, `dot FILE`\n  - Temporal commands: `until TS`, `range T1 T2`\n  - Schema commands: `schemas`, `schema TYPE`\n  - Subscription commands: `subscriptions`, `subscription NAME`\n  - Health commands: `health`, `memory`\n  - DOT export for Graphviz visualization","ref":"changelog.html#added-1"},{"type":"extras","title":"Changed - Changelog","doc":"- **Channel Server**: Updated `verify_capability/4` to use 3-mode security logic\n  - `disabled` mode: No capability checks (development/testing)\n  - `optional` mode: Verify if token provided, allow if not\n  - `required` mode: Always require valid capability token\n\n## [0.6.2] - 2025-12-22","ref":"changelog.html#changed-1"},{"type":"extras","title":"Added - Changelog","doc":"- **Stream Operations API**:\n  - `delete_stream/2` - Delete a stream and all its events\n  - `read_by_event_types/3` - Native Khepri filtering for type-based queries\n\n- **Subscription Operations API**:\n  - `get_subscription/2` - Get subscription details including checkpoint\n\nThese additions support the erl-evoq-esdb adapter improvements.\n\n## [0.6.1] - 2025-12-22","ref":"changelog.html#added-2"},{"type":"extras","title":"Changed - Changelog","doc":"- **Documentation Overhaul**: Fixed client-side guides to use correct gateway API\n  - `shared_types.md` - Replaced server API examples with `esdb_gater_api` calls\n  - `event_sourcing.md` - Updated 5 code samples to use gateway API\n  - `cqrs.md` - Updated projection examples to use `esdb_gater_api`\n  - `snapshots.md` - Complete rewrite with client-side perspective\n  - `subscriptions.md` - Complete rewrite with gateway API and PubSub channels\n  - `stream_links.md` - Updated subscription examples\n\n- **SVG Diagrams**: Replaced ASCII diagrams with professional SVG graphics\n  - `auth_traditional.svg` - Centralized authorization flow\n  - `auth_capability.svg` - Capability-based authorization flow\n  - `verification_flow.svg` - Token verification steps\n  - `delegation_chain.svg` - Permission delegation visualization\n  - `causation_chain.svg` - Event causation chain visualization\n\n## [0.6.0] - 2025-12-22","ref":"changelog.html#changed-2"},{"type":"extras","title":"Changed - Changelog","doc":"- **NIF Extraction**: Moved Rust NIF to separate `reckon-nifs` package\n  - NIFs are now loaded from `reckon_nifs` priv/ when available\n  - Falls back to `reckon_gater` priv/ for standalone builds\n  - Renamed NIF to `esdb_gater_crypto_nif` to avoid conflict with reckon-db's NIF\n  - Pure Erlang fallbacks unchanged for community edition\n\n- **Simplified Configuration**: Cleaned up rebar.config\n  - Removed commented NIF build hooks\n  - Added clear documentation for enterprise addon usage\n\n- **Documentation**: Updated README for new enterprise pattern\n  - Enterprise users now add `reckon_nifs` dependency\n  - Simplified instructions for NIF acceleration\n\n## [0.5.0] - 2025-12-22","ref":"changelog.html#changed-3"},{"type":"extras","title":"Added - Changelog","doc":"- **Temporal Query Operations** (`esdb_gater_api`):\n  - `read_until/3,4` - Read events up to a timestamp\n  - `read_range/4,5` - Read events in a time range\n  - `version_at/3` - Get stream version at a specific timestamp\n  - New guide: `guides/temporal_queries.md`\n\n- **Scavenge Operations** (`esdb_gater_api`):\n  - `scavenge/3` - Delete old events from a stream\n  - `scavenge_matching/3` - Scavenge streams matching a pattern\n  - `scavenge_dry_run/3` - Preview what would be deleted\n  - New guide: `guides/scavenging.md`\n\n- **Causation Tracking** (`esdb_gater_api`):\n  - `get_effects/2` - Get events caused by an event\n  - `get_cause/2` - Get the event that caused this one\n  - `get_causation_chain/2` - Trace back to root cause\n  - `get_correlated/2` - Get all events with same correlation ID\n  - `build_causation_graph/2` - Build graph for visualization\n  - New guide: `guides/causation.md`\n  - New SVG: `assets/causation_graph.svg`\n\n- **Schema Operations** (`esdb_gater_api`):\n  - `register_schema/3` - Register event schema with version\n  - `unregister_schema/2` - Remove a schema\n  - `get_schema/2` - Get schema for an event type\n  - `list_schemas/1` - List all registered schemas\n  - `get_schema_version/2` - Get current schema version\n  - `upcast_events/2` - Transform events to current schema\n  - New guide: `guides/schema_evolution.md`\n  - New SVG: `assets/schema_upcasting.svg`\n\n- **Memory Pressure Operations** (`esdb_gater_api`):\n  - `get_memory_level/1` - Get current pressure level (normal/elevated/critical)\n  - `get_memory_stats/1` - Get detailed memory statistics\n  - New guide: `guides/memory_pressure.md`\n\n- **Stream Link Operations** (`esdb_gater_api`):\n  - `create_link/2` - Create a derived stream with filter/transform\n  - `delete_link/2` - Delete a link\n  - `get_link/2` - Get link configuration\n  - `list_links/1` - List all links\n  - `start_link/2`, `stop_link/2` - Control link processing\n  - `link_info/2` - Get detailed link statistics\n  - New guide: `guides/stream_links.md`\n  - New SVG: `assets/stream_links.svg`","ref":"changelog.html#added-3"},{"type":"extras","title":"Changed - Changelog","doc":"- **README**: Added documentation for all new API sections\n- **ex_doc**: Added 6 new guides to documentation configuration\n\n## [0.4.3] - 2025-12-20","ref":"changelog.html#changed-4"},{"type":"extras","title":"Fixed - Changelog","doc":"- **Documentation**: Corrected all code samples in README.md\n  - Quick Start now uses actual descriptive API (`append_events`, `stream_forward`)\n  - API Reference documents real exports instead of non-existent `call`/`execute`\n  - \"Accessing the Event Store\" section uses correct function signatures\n  - Removed worker registration examples (server concern, not client)\n\n## [0.4.2] - 2025-12-20","ref":"changelog.html#fixed-2"},{"type":"extras","title":"Changed - Changelog","doc":"- **Documentation**: Replaced ASCII diagrams with SVG in README.md\n  - `supervision_tree.svg` - Supervision hierarchy\n  - `worker_registry_flow.svg` - Registration and execution flow\n  - `channel_message_flow.svg` - Publish message flow\n  - `worker_registration.svg` - Automatic worker registration architecture\n\n## [0.4.1] - 2025-12-20","ref":"changelog.html#changed-5"},{"type":"extras","title":"Changed - Changelog","doc":"- **Documentation**: Replaced ASCII diagrams with SVG in all guides\n  - `capability_architecture.svg` - Security architecture flow\n  - `cqrs_traditional.svg` - Traditional single model\n  - `cqrs_separated.svg` - CQRS command/query separation\n  - `cqrs_scaling.svg` - Independent read/write scaling\n  - `snapshots_comparison.svg` - Performance comparison\n  - `subscription_flow.svg` - Event write flow with triggers\n\n## [0.4.0] - 2025-12-20","ref":"changelog.html#changed-6"},{"type":"extras","title":"Added - Changelog","doc":"- **Capability-Based Security** (`esdb_capability.erl`, `esdb_identity.erl`):\n  - UCAN-inspired capability tokens for decentralized authorization\n  - Ed25519 keypair generation and DID encoding (`did:key` method)\n  - Token creation, signing, and delegation with attenuation\n  - JWT and Erlang binary encoding formats (auto-detected on decode)\n  - Base58 encoding for DIDs (Bitcoin alphabet)\n  - Shared types in `include/esdb_capability_types.hrl`\n  - Comprehensive security guide (`guides/capability_security.md`)\n\n- **Channel Capability Authorization**:\n  - `esdb_channel:publish/4` and `esdb_channel:subscribe/4` with capability token\n  - Channels can require capabilities via `requires_capability/0` callback\n  - Resource URI format: `esdb://{realm}/channel/{channel_name}/{topic}`\n  - Actions: `channel/publish` and `channel/subscribe`\n  - Integrates with `esdb_capability_verifier` in reckon-db for server-side verification\n\n- **Optional NIF Acceleration** (Enterprise Edition):\n  - Rust-based NIFs for Base58 encoding/decoding (5-10x faster)\n  - `esdb_crypto_nif.erl` wrapper with automatic fallback\n  - `native/` directory with Rust crate (excluded from hex.pm)\n  - Commented hooks in `rebar.config` for opt-in compilation\n  - Pattern: Community (hex.pm) = pure Erlang, Enterprise (git) = NIF-accelerated\n\nThis completes the capability-based security integration for PubSub channels.\n\n## [0.3.0] - 2024-12-20","ref":"changelog.html#added-4"},{"type":"extras","title":"Added - Changelog","doc":"- **Shared Types Header** (`include/esdb_gater_types.hrl`):\n  - `#event{}` record for event data\n  - `#snapshot{}` record for aggregate snapshots\n  - `#subscription{}` record for subscription state\n  - `#append_result{}` record for append operation results\n  - `subscription_type()` type (stream | event_type | event_pattern | event_payload)\n  - `read_direction()` type (forward | backward)\n  - `append_error()` and `read_error()` types\n  - Version constants: `?NO_STREAM`, `?ANY_VERSION`, `?STREAM_EXISTS`\n  - Content type constants: `?CONTENT_TYPE_JSON`, `?CONTENT_TYPE_BINARY`\n\nThis header enables downstream libraries (erl-evoq, erl-evoq-esdb) to depend on\nreckon-gater for shared type definitions without requiring a direct dependency\non reckon-db.\n\n## [0.2.0] - 2024-12-19","ref":"changelog.html#added-5"},{"type":"extras","title":"Changed - Changelog","doc":"- **Worker Registry**: Replaced Ra-based registry with pg-based implementation\n  - Uses OTP's built-in `pg` (process groups) module\n  - Simpler architecture with no external consensus dependency\n  - Cluster-wide discovery via `pg:get_members/2` across all nodes\n  - Eventual consistency model (acceptable for stateless gateway workers)\n  - Automatic cleanup on worker death via process monitoring\n  - Automatic cleanup on node failure via pg membership","ref":"changelog.html#changed-7"},{"type":"extras","title":"Removed - Changelog","doc":"- **Ra dependency**: No longer required since registry uses pg\n- **esdb_gater_api worker**: Removed from supervision tree (API is now purely functional)","ref":"changelog.html#removed"},{"type":"extras","title":"Added - Changelog","doc":"- **End-to-end tests**: 24 comprehensive e2e tests in reckon-db covering:\n  - Worker registration (4 tests)\n  - Stream operations via gater (9 tests)\n  - Subscription operations (4 tests)\n  - Snapshot operations (4 tests)\n  - Load balancing (3 tests)","ref":"changelog.html#added-6"},{"type":"extras","title":"Fixed - Changelog","doc":"- API compatibility with reckon-db gateway worker:\n  - `get_version` now handles integer return directly\n  - Snapshot operations use correct function names (`save`, `load_at`, `delete_at`)\n  - Subscription unsubscribe uses 3-arg version","ref":"changelog.html#fixed-3"},{"type":"extras","title":"Dependencies - Changelog","doc":"- Removed: Ra (no longer needed)\n- Telemetry 1.3.0 - BEAM telemetry for observability\n\n## [0.1.0] - 2024-12-18","ref":"changelog.html#dependencies"},{"type":"extras","title":"Added - Changelog","doc":"- Initial release of reckon-gater, gateway for distributed reckon-db access\n- Worker Registry:\n  - Ra-based distributed worker registration\n  - Automatic process monitoring and cleanup\n  - Node-aware worker lookup\n- Gateway API:\n  - `register_worker/1,2` - Register workers for stores\n  - `unregister_worker/1,2` - Unregister workers\n  - `call/2,3` - Synchronous calls with load balancing\n  - `cast/2` - Asynchronous fire-and-forget\n  - `get_workers/1` - List registered workers\n  - `health/0` - Gateway health status\n- Retry mechanism:\n  - Exponential backoff with jitter\n  - Configurable base delay, max delay, max attempts\n  - Telemetry integration for retry tracking\n- PubSub Channel System:\n  - `esdb_channel` behavior for channel implementations\n  - 10 dedicated channels with different priorities:\n    - Critical: alerts, security (HMAC required, no rate limit)\n    - High: events, health\n    - Normal: system, metrics, audit, lifecycle\n    - Low: logging, diagnostics\n  - Rate limiting per topic per second\n  - HMAC-SHA256 message signing for security\n  - Topic-based pub/sub using `pg` groups\n- Security:\n  - HMAC-SHA256 message signing\n  - Constant-time signature verification (timing attack resistant)\n  - Configurable message TTL (default 5 minutes)\n  - Environment variable or application config for secrets\n- Telemetry events:\n  - Worker registration/unregistration\n  - Request start/stop/error\n  - Retry attempts and exhaustion\n  - Cluster node up/down\n  - Channel broadcast metrics\n- Comprehensive test suite (44 unit + 8 integration tests)\n- Educational guides (shared with reckon-db):\n  - Event Sourcing fundamentals\n  - CQRS patterns\n  - Subscriptions usage\n  - Snapshots optimization","ref":"changelog.html#added-7"},{"type":"extras","title":"Dependencies - Changelog","doc":"- Ra 2.16.12 - Raft consensus for worker registry (replaced with pg in 0.2.0)\n- Telemetry 1.3.0 - BEAM telemetry for observability","ref":"changelog.html#dependencies-1"},{"type":"extras","title":"Configuration","doc":"# Configuration Guide\n\nThis guide covers all configuration options for reckon-gater, with examples for both Erlang (sys.config) and Elixir (config.exs).","ref":"configuration.html"},{"type":"extras","title":"Quick Start - Configuration","doc":"","ref":"configuration.html#quick-start"},{"type":"extras","title":"Erlang (sys.config) - Configuration","doc":"```erlang\n[\n  {reckon_gater, [\n    {capability_mode, optional},\n    {hmac_secret, <<\"your-secret-key-here\">>},\n    {retry, [\n      {base_delay_ms, 100},\n      {max_delay_ms, 30000},\n      {max_retries, 10}\n    ]}\n  ]}\n].\n```","ref":"configuration.html#erlang-sys-config"},{"type":"extras","title":"Elixir (config.exs) - Configuration","doc":"```elixir\nconfig :reckon_gater,\n  capability_mode: :optional,\n  hmac_secret: \"your-secret-key-here\",\n  retry: [\n    base_delay_ms: 100,\n    max_delay_ms: 30000,\n    max_retries: 10\n  ]\n```","ref":"configuration.html#elixir-config-exs"},{"type":"extras","title":"Configuration Reference - Configuration","doc":"","ref":"configuration.html#configuration-reference"},{"type":"extras","title":"Capability Security - Configuration","doc":"Controls how capability tokens are enforced across the gateway.\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `capability_mode` | atom | `disabled` | Global capability enforcement mode |\n\n**Modes:**\n\n- `disabled` - Capabilities are never checked (development/testing)\n- `optional` - Capabilities are verified if provided, allowed if not\n- `required` - Capabilities are always required for protected operations\n\n**Priority:** Per-channel overrides take precedence. If a channel's `requires_capability/0` callback returns `true`, that channel always requires capabilities regardless of the global setting.\n\n#### Erlang Example\n\n```erlang\n%% Development - no capability checks\n{capability_mode, disabled}\n\n%% Staging - verify if provided\n{capability_mode, optional}\n\n%% Production - always require\n{capability_mode, required}\n```\n\n#### Elixir Example\n\n```elixir\n# Development\nconfig :reckon_gater, capability_mode: :disabled\n\n# Staging\nconfig :reckon_gater, capability_mode: :optional\n\n# Production\nconfig :reckon_gater, capability_mode: :required\n```\n\n#### Runtime Configuration\n\nYou can change the capability mode at runtime:\n\n```erlang\n%% Erlang\nesdb_gater_config:set_capability_mode(required).\nesdb_gater_config:capability_mode().  %% Returns: required\n```\n\n```elixir\n# Elixir\n:esdb_gater_config.set_capability_mode(:required)\n:esdb_gater_config.capability_mode()  # Returns: :required\n```","ref":"configuration.html#capability-security"},{"type":"extras","title":"HMAC Security - Configuration","doc":"Used for signing messages on critical PubSub channels.\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `hmac_secret` | binary/string | auto-generated | Secret key for HMAC-SHA256 signing |\n\n**Environment Variable:** If not configured, falls back to `ESDB_GATER_SECRET` environment variable.\n\n**Warning:** If neither is configured, a random secret is generated. This is not recommended for production as it prevents message verification across restarts.\n\n#### Erlang Example\n\n```erlang\n%% Binary secret (recommended)\n{hmac_secret, <<\"my-production-secret-key-at-least-32-bytes\">>}\n\n%% String secret (converted to binary)\n{hmac_secret, \"my-production-secret-key-at-least-32-bytes\"}\n```\n\n#### Elixir Example\n\n```elixir\n# Using environment variable (recommended for production)\nconfig :reckon_gater,\n  hmac_secret: System.get_env(\"ESDB_GATER_SECRET\")\n\n# Direct configuration\nconfig :reckon_gater,\n  hmac_secret: \"my-production-secret-key-at-least-32-bytes\"\n```\n\n#### Runtime Configuration\n\n```erlang\n%% Erlang\nesdb_pubsub_security:set_secret(<<\"new-secret\">>).\nesdb_pubsub_security:get_secret().\n```\n\n```elixir\n# Elixir\n:esdb_pubsub_security.set_secret(\"new-secret\")\n:esdb_pubsub_security.get_secret()\n```","ref":"configuration.html#hmac-security"},{"type":"extras","title":"Retry Configuration - Configuration","doc":"Controls exponential backoff behavior for failed operations.\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `retry.base_delay_ms` | integer | 100 | Initial delay in milliseconds |\n| `retry.max_delay_ms` | integer | 30000 | Maximum delay cap in milliseconds |\n| `retry.max_retries` | integer | 10 | Maximum number of retry attempts |\n\n**Backoff Formula:** `delay = min(base_delay * 2^attempt + jitter, max_delay)`\n\nWhere jitter is 0-25% of the calculated delay.\n\n#### Erlang Example\n\n```erlang\n{retry, [\n  {base_delay_ms, 50},      %% Start at 50ms\n  {max_delay_ms, 60000},    %% Cap at 60 seconds\n  {max_retries, 5}          %% Give up after 5 attempts\n]}\n```\n\n#### Elixir Example\n\n```elixir\nconfig :reckon_gater,\n  retry: [\n    base_delay_ms: 50,\n    max_delay_ms: 60_000,\n    max_retries: 5\n  ]\n```\n\n#### Retry Sequence Example\n\nWith default configuration (`base_delay_ms: 100`, `max_delay_ms: 30000`):\n\n| Attempt | Base Delay | With Jitter (approx) |\n|---------|------------|----------------------|\n| 1 | 100ms | 100-125ms |\n| 2 | 200ms | 200-250ms |\n| 3 | 400ms | 400-500ms |\n| 4 | 800ms | 800-1000ms |\n| 5 | 1600ms | 1600-2000ms |\n| 6 | 3200ms | 3200-4000ms |\n| 7 | 6400ms | 6400-8000ms |\n| 8 | 12800ms | 12800-16000ms |\n| 9 | 25600ms | 25600-30000ms |\n| 10 | 30000ms | 30000ms (capped) |\n\nTotal worst-case wait: ~2 minutes before giving up.","ref":"configuration.html#retry-configuration"},{"type":"extras","title":"Complete Configuration Examples - Configuration","doc":"","ref":"configuration.html#complete-configuration-examples"},{"type":"extras","title":"Development Environment - Configuration","doc":"```erlang\n%% Erlang sys.config\n[\n  {reckon_gater, [\n    %% No capability enforcement in development\n    {capability_mode, disabled},\n\n    %% Short retries for fast feedback\n    {retry, [\n      {base_delay_ms, 50},\n      {max_delay_ms, 1000},\n      {max_retries, 3}\n    ]}\n  ]}\n].\n```\n\n```elixir\n# Elixir config/dev.exs\nconfig :reckon_gater,\n  capability_mode: :disabled,\n  retry: [\n    base_delay_ms: 50,\n    max_delay_ms: 1_000,\n    max_retries: 3\n  ]\n```","ref":"configuration.html#development-environment"},{"type":"extras","title":"Production Environment - Configuration","doc":"```erlang\n%% Erlang sys.config\n[\n  {reckon_gater, [\n    %% Strict capability enforcement\n    {capability_mode, required},\n\n    %% Secret from environment\n    {hmac_secret, {env, \"ESDB_GATER_SECRET\"}},\n\n    %% Patient retries for resilience\n    {retry, [\n      {base_delay_ms, 100},\n      {max_delay_ms, 60000},\n      {max_retries, 15}\n    ]}\n  ]}\n].\n```\n\n```elixir\n# Elixir config/runtime.exs\nconfig :reckon_gater,\n  capability_mode: :required,\n  hmac_secret: System.fetch_env!(\"ESDB_GATER_SECRET\"),\n  retry: [\n    base_delay_ms: 100,\n    max_delay_ms: 60_000,\n    max_retries: 15\n  ]\n```","ref":"configuration.html#production-environment"},{"type":"extras","title":"Staging/Testing Environment - Configuration","doc":"```elixir\n# Elixir config/test.exs\nconfig :reckon_gater,\n  # Optional mode for testing both paths\n  capability_mode: :optional,\n\n  # Fixed secret for reproducible tests\n  hmac_secret: \"test-secret-for-reproducibility\",\n\n  # Fast retries\n  retry: [\n    base_delay_ms: 10,\n    max_delay_ms: 100,\n    max_retries: 2\n  ]\n```","ref":"configuration.html#staging-testing-environment"},{"type":"extras","title":"Environment Variables - Configuration","doc":"| Variable | Description |\n|----------|-------------|\n| `ESDB_GATER_SECRET` | HMAC secret for message signing (fallback if not in config) |","ref":"configuration.html#environment-variables"},{"type":"extras","title":"Telemetry Events - Configuration","doc":"The gateway emits telemetry events for monitoring. Configure handlers via BEAM telemetry:\n\n```elixir\n# Elixir\n:telemetry.attach_many(\n  \"esdb-gater-handler\",\n  [\n    [:esdb_gater, :retry, :attempt],\n    [:esdb_gater, :retry, :exhausted],\n    [:esdb_gater, :request, :start],\n    [:esdb_gater, :request, :stop],\n    [:esdb_gater, :request, :exception]\n  ],\n  &MyApp.TelemetryHandler.handle_event/4,\n  nil\n)\n```\n\n```erlang\n%% Erlang\ntelemetry:attach_many(\n  <<\"esdb-gater-handler\">>,\n  [\n    [esdb_gater, retry, attempt],\n    [esdb_gater, retry, exhausted],\n    [esdb_gater, request, start],\n    [esdb_gater, request, stop],\n    [esdb_gater, request, exception]\n  ],\n  fun my_handler:handle_event/4,\n  undefined\n).\n```","ref":"configuration.html#telemetry-events"},{"type":"extras","title":"See Also - Configuration","doc":"- [Capability Security](capability_security.md) - Deep dive into capability tokens\n- [Interactive REPL](repl.md) - Interactive shell for exploration\n- [Event Sourcing](event_sourcing.md) - Core patterns","ref":"configuration.html#see-also"},{"type":"extras","title":"Event Sourcing","doc":"# Event Sourcing with reckon-db\n\nEvent Sourcing is an architectural pattern where the state of an application is determined by a sequence of events. Instead of storing just the current state, you store the complete history of state changes as immutable events.","ref":"event_sourcing.html"},{"type":"extras","title":"What is Event Sourcing? - Event Sourcing","doc":"Traditional CRUD-based systems store only the current state:\n\n```\nUser Record: {id: 123, name: \"Alice\", email: \"alice@example.com\", balance: 150}\n```\n\nEvent-sourced systems store the history of changes:\n\n```\nEvent 1: UserCreated {id: 123, name: \"Alice\", email: \"alice@example.com\"}\nEvent 2: BalanceDeposited {user_id: 123, amount: 200}\nEvent 3: BalanceWithdrawn {user_id: 123, amount: 50}\n```\n\nThe current state is derived by replaying these events.","ref":"event_sourcing.html#what-is-event-sourcing"},{"type":"extras","title":"Benefits of Event Sourcing - Event Sourcing","doc":"","ref":"event_sourcing.html#benefits-of-event-sourcing"},{"type":"extras","title":"Complete Audit Trail - Event Sourcing","doc":"Every change is recorded with a timestamp and metadata. This is invaluable for:\n- Regulatory compliance (financial systems, healthcare)\n- Debugging production issues\n- Understanding user behavior","ref":"event_sourcing.html#complete-audit-trail"},{"type":"extras","title":"Temporal Queries - Event Sourcing","doc":"You can reconstruct the state at any point in time:\n\n```erlang\n%% Get account balance as of last month\n{ok, Events} = esdb_gater_api:stream_forward(my_store, <<\"account-123\">>, 0, 1000),\nPastEvents = [E || E <- Events, E#event.timestamp < LastMonthTimestamp],\nBalance = lists:foldl(fun apply_event/2, 0, PastEvents).\n```","ref":"event_sourcing.html#temporal-queries"},{"type":"extras","title":"Event Replay - Event Sourcing","doc":"Rebuild read models, fix bugs in projections, or create new views of historical data:\n\n```erlang\n%% Rebuild a projection from scratch\n{ok, Events} = esdb_gater_api:stream_forward(my_store, <<\"orders-*\">>, 0, 10000),\nlists:foreach(fun(E) -> update_projection(E) end, Events).\n```","ref":"event_sourcing.html#event-replay"},{"type":"extras","title":"Decoupled Systems - Event Sourcing","doc":"Events can be consumed by multiple subscribers independently:\n\n```\nOrder Placed Event\n    |\n    +---> Inventory Service (decrements stock)\n    +---> Notification Service (sends email)\n    +---> Analytics Service (updates metrics)\n    +---> Billing Service (creates invoice)\n```","ref":"event_sourcing.html#decoupled-systems"},{"type":"extras","title":"Event Sourcing with reckon-db - Event Sourcing","doc":"","ref":"event_sourcing.html#event-sourcing-with-reckon-db"},{"type":"extras","title":"Streams - Event Sourcing","doc":"A **stream** is an ordered sequence of events sharing a common identifier (the stream ID). Streams typically represent:\n- An aggregate (e.g., `order-123`, `user-456`)\n- A category (e.g., `orders`, `users`)\n- A partition (e.g., `orders-region-eu`)\n\n```erlang\n%% Append events to a stream via gateway\nEvents = [\n    #{\n        event_type => <<\"OrderPlaced\">>,\n        data => #{order_id => <<\"ord-123\">>, items => [...], total => 9999},\n        metadata => #{user_id => <<\"user-456\">>, correlation_id => <<\"req-789\">>}\n    }\n],\n{ok, Version} = esdb_gater_api:append_events(my_store, <<\"order-ord-123\">>, Events).\n```","ref":"event_sourcing.html#streams"},{"type":"extras","title":"Events - Event Sourcing","doc":"Events are immutable facts that have happened. They should:\n- Be named in past tense (e.g., `OrderPlaced`, not `PlaceOrder`)\n- Contain all information needed to understand what happened\n- Be business-meaningful (e.g., `AccountOverdrawn`, not `BalanceUpdated`)\n\n```erlang\n%% Event structure\n#{\n    event_type => <<\"OrderPlaced\">>,      %% What happened\n    data => #{                             %% The event payload\n        order_id => <<\"ord-123\">>,\n        customer_id => <<\"cust-456\">>,\n        items => [\n            #{product_id => <<\"prod-1\">>, quantity => 2, price => 1999}\n        ],\n        total => 3998\n    },\n    metadata => #{                         %% Cross-cutting concerns\n        correlation_id => <<\"req-abc\">>,   %% Traces related operations\n        causation_id => <<\"evt-xyz\">>,     %% What caused this event\n        user_id => <<\"user-789\">>,         %% Who triggered it\n        timestamp => 1703001234567         %% When it happened\n    }\n}\n```","ref":"event_sourcing.html#events"},{"type":"extras","title":"Optimistic Concurrency - Event Sourcing","doc":"reckon-db uses optimistic concurrency control to prevent conflicting writes:\n\n```erlang\n%% Expected version semantics (via options):\n%% expected_version => -1 (NO_STREAM): Stream must not exist (first write)\n%% expected_version => -2 (ANY_VERSION): No version check, always append\n%% expected_version => N >= 0: Stream version must equal N\n\n%% First write to a new stream\n{ok, 0} = esdb_gater_api:append_events(my_store, <<\"order-123\">>, [Event1],\n    #{expected_version => -1}).\n\n%% Subsequent writes must specify expected version\n{ok, 1} = esdb_gater_api:append_events(my_store, <<\"order-123\">>, [Event2],\n    #{expected_version => 0}).\n\n%% Concurrent writes will fail with version mismatch\n%% Process A reads version 1\n%% Process B reads version 1\n%% Process A writes with expected version 1 -> succeeds, version is now 2\n%% Process B writes with expected version 1 -> fails! (wrong_expected_version)\n```","ref":"event_sourcing.html#optimistic-concurrency"},{"type":"extras","title":"Designing Events - Event Sourcing","doc":"","ref":"event_sourcing.html#designing-events"},{"type":"extras","title":"Event Naming - Event Sourcing","doc":"Use past tense verbs that describe business facts:\n\n| Good | Bad |\n|------|-----|\n| `OrderPlaced` | `CreateOrder` |\n| `PaymentReceived` | `ProcessPayment` |\n| `ItemShipped` | `ShipItem` |\n| `AccountOverdrawn` | `UpdateBalance` |","ref":"event_sourcing.html#event-naming"},{"type":"extras","title":"Event Granularity - Event Sourcing","doc":"Events should be atomic business facts. Avoid:\n- Generic events like `EntityUpdated` (not meaningful)\n- Overly fine-grained events (one per field change)\n- Composite events (multiple unrelated changes)\n\n```erlang\n%% Good: Specific, meaningful events\n#{event_type => <<\"AddressChanged\">>, data => #{\n    old_address => OldAddr,\n    new_address => NewAddr,\n    reason => <<\"customer_request\">>\n}}\n\n%% Bad: Generic, meaningless event\n#{event_type => <<\"CustomerUpdated\">>, data => #{\n    field => <<\"address\">>,\n    value => NewAddr\n}}\n```","ref":"event_sourcing.html#event-granularity"},{"type":"extras","title":"Event Versioning - Event Sourcing","doc":"Events are immutable, but schemas evolve. Use explicit versions:\n\n```erlang\n%% Version 1\n#{event_type => <<\"OrderPlaced.v1\">>, data => #{\n    order_id => ...,\n    items => [...]\n}}\n\n%% Version 2 (added shipping_address)\n#{event_type => <<\"OrderPlaced.v2\">>, data => #{\n    order_id => ...,\n    items => [...],\n    shipping_address => #{}\n}}\n```\n\nHandle schema evolution in your projections:\n\n```erlang\nhandle_event(#{event_type := <<\"OrderPlaced.v1\">>} = Event) ->\n    %% Default shipping address for v1 events\n    upgrade_to_v2(Event);\nhandle_event(#{event_type := <<\"OrderPlaced.v2\">>} = Event) ->\n    process_order(Event).\n```","ref":"event_sourcing.html#event-versioning"},{"type":"extras","title":"Building Aggregates - Event Sourcing","doc":"An **aggregate** is a domain object that encapsulates state and enforces invariants. In event sourcing, aggregates:\n1. Load their state by replaying events\n2. Validate commands against current state\n3. Emit new events if the command succeeds\n\n```erlang\n-module(order_aggregate).\n-export([new/0, apply_event/2, place_order/2, add_item/3]).\n\n-record(order, {\n    id,\n    status = pending,\n    items = [],\n    total = 0\n}).\n\n%% Create a new aggregate\nnew() -> #order{}.\n\n%% Apply events to rebuild state\napply_event(#{event_type := <<\"OrderPlaced\">>} = E, _Order) ->\n    Data = maps:get(data, E),\n    #order{\n        id = maps:get(order_id, Data),\n        status = placed,\n        items = maps:get(items, Data),\n        total = maps:get(total, Data)\n    };\n\napply_event(#{event_type := <<\"ItemAdded\">>} = E, Order) ->\n    Data = maps:get(data, E),\n    NewItem = #{\n        product_id => maps:get(product_id, Data),\n        quantity => maps:get(quantity, Data),\n        price => maps:get(price, Data)\n    },\n    Order#order{\n        items = [NewItem | Order#order.items],\n        total = Order#order.total + (maps:get(quantity, Data) * maps:get(price, Data))\n    };\n\napply_event(#{event_type := <<\"OrderShipped\">>}, Order) ->\n    Order#order{status = shipped}.\n\n%% Commands that produce events\nplace_order(OrderId, Items) ->\n    Total = lists:sum([Q * P || #{quantity := Q, price := P} <- Items]),\n    {ok, [#{\n        event_type => <<\"OrderPlaced\">>,\n        data => #{order_id => OrderId, items => Items, total => Total}\n    }]}.\n\nadd_item(#order{status = placed} = _Order, ProductId, Quantity) ->\n    Price = get_product_price(ProductId),\n    {ok, [#{\n        event_type => <<\"ItemAdded\">>,\n        data => #{product_id => ProductId, quantity => Quantity, price => Price}\n    }]};\nadd_item(#order{status = shipped}, _ProductId, _Quantity) ->\n    {error, order_already_shipped}.\n```","ref":"event_sourcing.html#building-aggregates"},{"type":"extras","title":"Loading Aggregate State - Event Sourcing","doc":"Rebuild aggregate state by reading and folding events:\n\n```erlang\n%% Load order aggregate from event stream via gateway\nload_order(StoreId, OrderId) ->\n    StreamId = <<\"order-\", OrderId/binary>>,\n    {ok, Events} = esdb_gater_api:stream_forward(StoreId, StreamId, 0, 10000),\n    lists:foldl(fun order_aggregate:apply_event/2, order_aggregate:new(), Events).\n```","ref":"event_sourcing.html#loading-aggregate-state"},{"type":"extras","title":"Further Reading - Event Sourcing","doc":"- [CQRS Guide](cqrs.md) - Command Query Responsibility Segregation\n- [Subscriptions Guide](subscriptions.md) - Real-time event notifications\n- [Snapshots Guide](snapshots.md) - Optimizing aggregate loading","ref":"event_sourcing.html#further-reading"},{"type":"extras","title":"References - Event Sourcing","doc":"- Martin Fowler: [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)\n- Greg Young: [CQRS and Event Sourcing](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)\n- Vaughn Vernon: \"Implementing Domain-Driven Design\" (Chapters 8-10)","ref":"event_sourcing.html#references"},{"type":"extras","title":"CQRS","doc":"# CQRS with reckon-db\n\nCommand Query Responsibility Segregation (CQRS) is an architectural pattern that separates read and write operations into distinct models. Combined with event sourcing, CQRS enables highly scalable and maintainable systems.","ref":"cqrs.html"},{"type":"extras","title":"What is CQRS? - CQRS","doc":"In traditional architectures, the same model handles both reads and writes:\n\n![Traditional Architecture](assets/cqrs_traditional.svg)\n\nCQRS separates these concerns:\n\n![CQRS Separated Architecture](assets/cqrs_separated.svg)","ref":"cqrs.html#what-is-cqrs"},{"type":"extras","title":"Why CQRS? - CQRS","doc":"","ref":"cqrs.html#why-cqrs"},{"type":"extras","title":"Different Optimization Strategies - CQRS","doc":"Reads and writes have fundamentally different characteristics:\n\n| Writes | Reads |\n|--------|-------|\n| Validate business rules | No validation needed |\n| Must be consistent | Can be eventually consistent |\n| Lower volume | Higher volume (often 10-100x) |\n| Complex domain logic | Simple queries |\n\nWith CQRS, you optimize each path independently:\n- **Write side**: Focus on business logic, invariants, and consistency\n- **Read side**: Focus on query performance, denormalization, and caching","ref":"cqrs.html#different-optimization-strategies"},{"type":"extras","title":"Scalability - CQRS","doc":"Read and write workloads can scale independently:\n\n![CQRS Scaling](assets/cqrs_scaling.svg)","ref":"cqrs.html#scalability"},{"type":"extras","title":"Multiple Read Models - CQRS","doc":"Different consumers can have different views of the same data:\n\n```erlang\n%% Same events, different read models\n\n%% Order Events Stream\n[\n    #{event_type => <<\"OrderPlaced\">>, data => #{...}},\n    #{event_type => <<\"PaymentReceived\">>, data => #{...}},\n    #{event_type => <<\"OrderShipped\">>, data => #{...}}\n]\n\n%% Read Model 1: Customer Dashboard (optimized for display)\n#{\n    order_id => <<\"ord-123\">>,\n    status => <<\"Shipped\">>,\n    status_history => [...],\n    tracking_url => <<\"https://...\">>\n}\n\n%% Read Model 2: Warehouse System (optimized for picking)\n#{\n    order_id => <<\"ord-123\">>,\n    items => [#{sku => ..., location => ..., quantity => ...}],\n    priority => high,\n    shipping_method => express\n}\n\n%% Read Model 3: Analytics (optimized for aggregation)\n#{\n    date => <<\"2024-01-15\">>,\n    region => <<\"EU\">>,\n    total_orders => 1547,\n    total_revenue => 234567,\n    avg_order_value => 151.63\n}\n```","ref":"cqrs.html#multiple-read-models"},{"type":"extras","title":"CQRS with reckon-db - CQRS","doc":"","ref":"cqrs.html#cqrs-with-reckon-db"},{"type":"extras","title":"The Command Side - CQRS","doc":"Commands represent intentions to change state. They are validated and may produce events:\n\n```erlang\n-module(order_commands).\n-export([handle/2]).\n\n%% Handle PlaceOrder command\nhandle({place_order, OrderId, CustomerId, Items}, State) ->\n    %% Validate business rules\n    case validate_items(Items) of\n        {error, Reason} ->\n            {error, Reason};\n        ok ->\n            %% Check inventory\n            case check_inventory(Items) of\n                {error, out_of_stock} ->\n                    {error, items_out_of_stock};\n                ok ->\n                    %% Generate events\n                    Total = calculate_total(Items),\n                    Event = #{\n                        event_type => <<\"OrderPlaced\">>,\n                        data => #{\n                            order_id => OrderId,\n                            customer_id => CustomerId,\n                            items => Items,\n                            total => Total\n                        },\n                        metadata => #{\n                            command => place_order,\n                            timestamp => erlang:system_time(millisecond)\n                        }\n                    },\n                    {ok, [Event]}\n            end\n    end;\n\n%% Handle CancelOrder command\nhandle({cancel_order, OrderId, Reason}, State) ->\n    %% Load current state\n    Order = load_order(State, OrderId),\n    case Order#order.status of\n        shipped ->\n            {error, cannot_cancel_shipped_order};\n        cancelled ->\n            {error, already_cancelled};\n        _ ->\n            Event = #{\n                event_type => <<\"OrderCancelled\">>,\n                data => #{order_id => OrderId, reason => Reason}\n            },\n            {ok, [Event]}\n    end.\n```","ref":"cqrs.html#the-command-side"},{"type":"extras","title":"The Query Side: Projections - CQRS","doc":"Projections transform events into read models. They run asynchronously and subscribe to event streams:\n\n```erlang\n-module(order_dashboard_projection).\n-behaviour(gen_server).\n\n-export([start_link/1, get_order/1, list_customer_orders/1]).\n-export([init/1, handle_info/2, handle_call/3]).\n\n%% Read model stored in ETS for fast lookups\n-define(TABLE, order_dashboard).\n\nstart_link(StoreId) ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, StoreId, []).\n\ninit(StoreId) ->\n    %% Create ETS table for read model\n    ets:new(?TABLE, [named_table, public, {read_concurrency, true}]),\n\n    %% Subscribe to order events via gateway\n    ok = esdb_gater_api:save_subscription(\n        StoreId,\n        event_pattern,\n        <<\"order-*\">>,\n        <<\"order_dashboard_projection\">>,\n        self(),\n        #{}\n    ),\n\n    %% Also subscribe to PubSub channel for real-time delivery\n    ok = esdb_channel_server:subscribe(esdb_channel_events, <<\"order.*\">>, self()),\n\n    {ok, #{store_id => StoreId}}.\n\n%% Handle events from subscription\nhandle_info({event, Event}, State) ->\n    project_event(Event),\n    {noreply, State}.\n\n%% Query interface\nget_order(OrderId) ->\n    case ets:lookup(?TABLE, {order, OrderId}) of\n        [{_, Order}] -> {ok, Order};\n        [] -> {error, not_found}\n    end.\n\nlist_customer_orders(CustomerId) ->\n    Pattern = {{customer_order, CustomerId, '_'}, '_'},\n    Orders = ets:match_object(?TABLE, Pattern),\n    {ok, [Order || {_, Order} <- Orders]}.\n\n%% Project events into read model\nproject_event(#{event_type := <<\"OrderPlaced\">>} = Event) ->\n    Data = maps:get(data, Event),\n    OrderId = maps:get(order_id, Data),\n    CustomerId = maps:get(customer_id, Data),\n\n    %% Denormalized read model optimized for display\n    ReadModel = #{\n        order_id => OrderId,\n        customer_id => CustomerId,\n        items => maps:get(items, Data),\n        total => maps:get(total, Data),\n        status => <<\"Placed\">>,\n        status_history => [#{status => <<\"Placed\">>, at => Event#event.timestamp}],\n        placed_at => Event#event.timestamp\n    },\n\n    %% Store by order ID\n    ets:insert(?TABLE, {{order, OrderId}, ReadModel}),\n\n    %% Index by customer for listing\n    ets:insert(?TABLE, {{customer_order, CustomerId, OrderId}, ReadModel});\n\nproject_event(#{event_type := <<\"OrderShipped\">>} = Event) ->\n    Data = maps:get(data, Event),\n    OrderId = maps:get(order_id, Data),\n\n    %% Update existing read model\n    case ets:lookup(?TABLE, {order, OrderId}) of\n        [{Key, Order}] ->\n            Updated = Order#{\n                status => <<\"Shipped\">>,\n                status_history => [\n                    #{status => <<\"Shipped\">>, at => Event#event.timestamp}\n                    | maps:get(status_history, Order)\n                ],\n                tracking_number => maps:get(tracking_number, Data, undefined),\n                shipped_at => Event#event.timestamp\n            },\n            ets:insert(?TABLE, {Key, Updated}),\n\n            %% Update customer index too\n            CustomerId = maps:get(customer_id, Order),\n            ets:insert(?TABLE, {{customer_order, CustomerId, OrderId}, Updated});\n        [] ->\n            %% Event for unknown order - log warning\n            logger:warning(\"OrderShipped for unknown order: ~p\", [OrderId])\n    end;\n\nproject_event(_Event) ->\n    %% Ignore events we don't care about\n    ok.\n```","ref":"cqrs.html#the-query-side-projections"},{"type":"extras","title":"Multiple Projections - CQRS","doc":"The same events can drive multiple specialized read models:\n\n```erlang\n%% Analytics projection - aggregates for dashboards\n-module(order_analytics_projection).\n\nproject_event(#{event_type := <<\"OrderPlaced\">>} = Event) ->\n    Data = maps:get(data, Event),\n    Date = date_from_timestamp(Event#event.timestamp),\n    Total = maps:get(total, Data),\n    Region = get_customer_region(maps:get(customer_id, Data)),\n\n    %% Increment daily counters\n    ets:update_counter(?ANALYTICS_TABLE, {daily_orders, Date, Region}, 1, {{daily_orders, Date, Region}, 0}),\n    ets:update_counter(?ANALYTICS_TABLE, {daily_revenue, Date, Region}, Total, {{daily_revenue, Date, Region}, 0}).\n\n%% Inventory projection - tracks stock levels\n-module(inventory_projection).\n\nproject_event(#{event_type := <<\"OrderPlaced\">>} = Event) ->\n    Items = maps:get(items, maps:get(data, Event)),\n    lists:foreach(fun(#{product_id := ProductId, quantity := Qty}) ->\n        %% Decrement reserved stock\n        ets:update_counter(?INVENTORY_TABLE, {reserved, ProductId}, Qty, {{reserved, ProductId}, 0})\n    end, Items);\n\nproject_event(#{event_type := <<\"OrderShipped\">>} = Event) ->\n    Items = maps:get(items, maps:get(data, Event)),\n    lists:foreach(fun(#{product_id := ProductId, quantity := Qty}) ->\n        %% Move from reserved to shipped\n        ets:update_counter(?INVENTORY_TABLE, {reserved, ProductId}, -Qty),\n        ets:update_counter(?INVENTORY_TABLE, {shipped, ProductId}, Qty, {{shipped, ProductId}, 0})\n    end, Items).\n```","ref":"cqrs.html#multiple-projections"},{"type":"extras","title":"Eventual Consistency - CQRS","doc":"With CQRS, read models are **eventually consistent** with the write model. This means:\n\n1. A command succeeds and events are written\n2. Projections receive events asynchronously\n3. Read models are updated\n4. Queries return the updated data\n\nThere's a delay between steps 1 and 4. This is usually milliseconds, but can be longer under load.","ref":"cqrs.html#eventual-consistency"},{"type":"extras","title":"Handling Eventual Consistency - CQRS","doc":"**In the UI:**\n```erlang\n%% After successful command, show optimistic update\ncase order_commands:handle(PlaceOrderCmd, State) of\n    {ok, Events} ->\n        %% Write events via gateway\n        {ok, Version} = esdb_gater_api:append_events(\n            my_store, StreamId, Events,\n            #{expected_version => ExpectedVer}\n        ),\n\n        %% Return success with the data the client needs\n        %% Don't query the read model yet - it might not be updated\n        {ok, #{\n            order_id => OrderId,\n            status => <<\"Placed\">>,\n            message => <<\"Order placed successfully\">>\n        }};\n    {error, Reason} ->\n        {error, Reason}\nend.\n```\n\n**For critical queries:**\n```erlang\n%% If consistency is critical, query the event store via gateway\nget_order_status(StoreId, OrderId) ->\n    StreamId = <<\"order-\", OrderId/binary>>,\n    {ok, Events} = esdb_gater_api:stream_forward(StoreId, StreamId, 0, 1000),\n\n    %% Derive status from events\n    Status = lists:foldl(fun\n        (#event{event_type = <<\"OrderPlaced\">>}, _) -> placed;\n        (#event{event_type = <<\"OrderShipped\">>}, _) -> shipped;\n        (#event{event_type = <<\"OrderDelivered\">>}, _) -> delivered;\n        (#event{event_type = <<\"OrderCancelled\">>}, _) -> cancelled;\n        (_, Acc) -> Acc\n    end, unknown, Events),\n\n    {ok, Status}.\n```","ref":"cqrs.html#handling-eventual-consistency"},{"type":"extras","title":"Best Practices - CQRS","doc":"","ref":"cqrs.html#best-practices"},{"type":"extras","title":"1. Keep Projections Idempotent - CQRS","doc":"Projections may receive the same event multiple times (redelivery, replay). Make them idempotent:\n\n```erlang\n%% Bad: Not idempotent\nproject_event(#{event_type := <<\"ItemAdded\">>} = E) ->\n    OrderId = maps:get(order_id, maps:get(data, E)),\n    ets:update_counter(?TABLE, {item_count, OrderId}, 1).  %% Will double-count on replay\n\n%% Good: Idempotent using event version\nproject_event(#{event_type := <<\"ItemAdded\">>} = E) ->\n    OrderId = maps:get(order_id, maps:get(data, E)),\n    EventVersion = E#event.version,\n\n    case ets:lookup(?TABLE, {last_version, OrderId}) of\n        [{_, LastVersion}] when EventVersion = \n            %% Already processed this event\n            ok;\n        _ ->\n            %% Process and update version\n            ets:update_counter(?TABLE, {item_count, OrderId}, 1),\n            ets:insert(?TABLE, {{last_version, OrderId}, EventVersion})\n    end.\n```","ref":"cqrs.html#1-keep-projections-idempotent"},{"type":"extras","title":"2. Design Read Models for Queries - CQRS","doc":"Don't normalize read models. Denormalize for query performance:\n\n```erlang\n%% Read model for \"show customer's recent orders with item details\"\n%% Everything needed in one lookup\n#{\n    customer_id => <<\"cust-123\">>,\n    recent_orders => [\n        #{\n            order_id => <<\"ord-456\">>,\n            placed_at => 1703001234567,\n            status => <<\"Delivered\">>,\n            items => [\n                #{name => <<\"Widget\">>, quantity => 2, price => 999}\n            ],\n            total => 1998\n        }\n    ]\n}\n```","ref":"cqrs.html#2-design-read-models-for-queries"},{"type":"extras","title":"3. Separate Projection Processes - CQRS","doc":"Run projections in separate processes for isolation:\n\n```erlang\n%% In your supervisor\n{ok, _} = order_dashboard_projection:start_link(StoreId),\n{ok, _} = order_analytics_projection:start_link(StoreId),\n{ok, _} = inventory_projection:start_link(StoreId).\n```\n\nIf one projection fails or falls behind, others continue working.","ref":"cqrs.html#3-separate-projection-processes"},{"type":"extras","title":"Further Reading - CQRS","doc":"- [Event Sourcing Guide](event_sourcing.md) - Foundation for CQRS\n- [Subscriptions Guide](subscriptions.md) - Event delivery for projections\n- [Snapshots Guide](snapshots.md) - Optimizing projection rebuilds","ref":"cqrs.html#further-reading"},{"type":"extras","title":"References - CQRS","doc":"- Martin Fowler: [CQRS](https://martinfowler.com/bliki/CQRS.html)\n- Greg Young: [CQRS Documents](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)\n- Udi Dahan: [Clarified CQRS](https://udidahan.com/2009/12/09/clarified-cqrs/)","ref":"cqrs.html#references"},{"type":"extras","title":"Interactive REPL","doc":"# Interactive REPL\n\nThe reckon-gater REPL (Read-Eval-Print-Loop) provides an interactive shell for exploring event stores, streams, causation chains, and temporal queries. It's designed for developers to quickly inspect and debug event-sourced systems without writing code.\n\n![REPL Architecture](../assets/repl_architecture.svg)","ref":"repl.html"},{"type":"extras","title":"Overview - Interactive REPL","doc":"The REPL provides a stateful session that maintains context about:\n- **Current store** - Which event store you're connected to\n- **Current stream** - Which event stream is selected for operations\n\nThis context-aware design means you don't need to specify the store and stream for every command once they're selected.","ref":"repl.html#overview"},{"type":"extras","title":"Quick Start - Interactive REPL","doc":"Start the REPL from an Erlang shell:\n\n```erlang\n%% Start without a store selected\nesdb_gater_repl:start().\n\n%% Start with a store pre-selected\nesdb_gater_repl:start(my_store).\n```","ref":"repl.html#quick-start"},{"type":"extras","title":"Command Reference - Interactive REPL","doc":"","ref":"repl.html#command-reference"},{"type":"extras","title":"Store Commands - Interactive REPL","doc":"```\nstores              List all stores\nuse STORE           Set current store context\n```\n\nExample session:\n\n```\nesdb> stores\n\nStores:\n  my_store\n  another_store\n\nesdb> use my_store\nSwitched to store: my_store\nesdb:my_store>\n```","ref":"repl.html#store-commands"},{"type":"extras","title":"Stream Commands - Interactive REPL","doc":"```\nstreams             List streams in current store\nstream STREAM       Set current stream context\nread [N]            Read N events (default 10)\nread STREAM [N]     Read N events from stream\nversion             Get version of current stream\nversion STREAM      Get version of stream\n```\n\nExample session:\n\n```\nesdb:my_store> streams\n\nStreams in my_store:\n  orders\n  customers\n  products\n\nTotal: 3 streams\n\nesdb:my_store> stream orders\nSwitched to stream: orders\n\nesdb:my_store/orders> read 5\n\n  [0] order_created: evt-123\n  [1] order_paid: evt-124\n  [2] order_shipped: evt-125\n  [3] order_delivered: evt-126\n  [4] order_completed: evt-127\n\nTotal: 5 events\n\nesdb:my_store/orders> version\nVersion: 127\n```","ref":"repl.html#stream-commands"},{"type":"extras","title":"Causation Commands - Interactive REPL","doc":"Causation tracking is one of the most powerful features of the REPL. It allows you to trace the lineage of events through your system.\n\n![Causation Workflow](../assets/repl_causation_workflow.svg)\n\n```\neffects ID          Get events caused by event\ncause ID            Get event that caused this\nchain ID            Get full causation chain\ngraph ID            Build and display causation graph\ndot ID FILE         Export graph as Graphviz DOT file\n```\n\nExample session:\n\n```\nesdb:my_store> effects evt-100\n\nEvents caused by evt-100:\n  [0] payment_processed: evt-101\n  [1] inventory_reserved: evt-102\n\nTotal: 2 effects\n\nesdb:my_store> chain evt-105\n\nCausation chain to evt-105:\n  [1] order_created (evt-100)\n  -> [2] payment_processed (evt-101)\n  -> [3] inventory_reserved (evt-102)\n  -> [4] order_shipped (evt-104)\n  -> [5] delivery_scheduled (evt-105)\n\nChain length: 5\n\nesdb:my_store> dot evt-100 /tmp/causation.dot\nDOT file written to: /tmp/causation.dot\n```\n\nTo visualize the DOT file:\n\n```bash\ndot -Tpng /tmp/causation.dot -o /tmp/causation.png\n```","ref":"repl.html#causation-commands"},{"type":"extras","title":"Temporal Commands - Interactive REPL","doc":"```\nuntil TS            Read events until timestamp\nrange T1 T2         Read events in time range\n```\n\nTimestamps are Unix epoch in seconds.\n\nExample session:\n\n```\nesdb:my_store/orders> until 1703200000\n\nEvents until 1703200000:\n  [0] order_created: evt-123\n  [1] order_paid: evt-124\n\nTotal: 2 events\n\nesdb:my_store/orders> range 1703100000 1703200000\n\nEvents from 1703100000 to 1703200000:\n  [0] order_created: evt-123\n  [1] order_paid: evt-124\n  [2] order_shipped: evt-125\n\nTotal: 3 events\n```","ref":"repl.html#temporal-commands"},{"type":"extras","title":"Schema Commands - Interactive REPL","doc":"```\nschemas             List all schemas\nschema TYPE         Get schema for event type\n```","ref":"repl.html#schema-commands"},{"type":"extras","title":"Subscription Commands - Interactive REPL","doc":"```\nsubscriptions       List all subscriptions\nsubscription NAME   Get subscription details\n```","ref":"repl.html#subscription-commands"},{"type":"extras","title":"Health Commands - Interactive REPL","doc":"```\nhealth              Gateway health status\nmemory              Memory statistics for current store\n```\n\nExample:\n\n```\nesdb> health\n\nGateway Health:\n  status: healthy\n  stores: #{my_store => 3, another_store => 2}\n  total_workers: 5\n  node: 'node1@localhost'\n  timestamp: 1703234567890\n```","ref":"repl.html#health-commands"},{"type":"extras","title":"Prompt Format - Interactive REPL","doc":"The prompt shows your current context:\n\n```\nesdb>                           # No store selected\nesdb:my_store>                  # Store selected\nesdb:my_store/orders>           # Store + stream selected\n```","ref":"repl.html#prompt-format"},{"type":"extras","title":"Tips - Interactive REPL","doc":"1. **Tab completion**: Not supported yet, but coming in a future release.\n\n2. **History**: Use up/down arrows if your shell supports it (depends on terminal).\n\n3. **Batch operations**: For bulk operations, use the `esdb_gater_api` module directly instead of the REPL.\n\n4. **DOT files**: The `dot` command generates Graphviz DOT format, which can be converted to PNG, SVG, or PDF using the `dot` command-line tool.","ref":"repl.html#tips"},{"type":"extras","title":"Use Cases - Interactive REPL","doc":"","ref":"repl.html#use-cases"},{"type":"extras","title":"Debugging Event Flows - Interactive REPL","doc":"When an event causes unexpected behavior, use causation commands to trace its origin:\n\n```\nesdb:my_store> chain problematic-event-id\n```\n\nThis shows the full chain of events that led to the problematic event, helping identify where things went wrong.","ref":"repl.html#debugging-event-flows"},{"type":"extras","title":"Investigating Time-Based Issues - Interactive REPL","doc":"For issues that occurred at a specific time, use temporal queries:\n\n```\nesdb:my_store/orders> range 1703100000 1703110000\n```\n\nThis shows all events in the orders stream during that 10-second window.","ref":"repl.html#investigating-time-based-issues"},{"type":"extras","title":"Exporting Visualizations - Interactive REPL","doc":"Generate DOT files for documentation or sharing:\n\n```\nesdb:my_store> dot correlation-id-123 /tmp/saga-flow.dot\n```\n\nThen convert to various formats:\n\n```bash\n# PNG image\ndot -Tpng /tmp/saga-flow.dot -o /tmp/saga-flow.png\n\n# SVG (scalable)\ndot -Tsvg /tmp/saga-flow.dot -o /tmp/saga-flow.svg\n\n# PDF document\ndot -Tpdf /tmp/saga-flow.dot -o /tmp/saga-flow.pdf\n```","ref":"repl.html#exporting-visualizations"},{"type":"extras","title":"Monitoring Health - Interactive REPL","doc":"Quick health check of the gateway:\n\n```\nesdb> health\n```\n\nCheck memory pressure for a specific store:\n\n```\nesdb:my_store> memory\n```","ref":"repl.html#monitoring-health"},{"type":"extras","title":"Integration with Development Workflow - Interactive REPL","doc":"The REPL is designed to fit into your development workflow:\n\n1. **During Development**: Quickly verify events are being stored correctly\n2. **Debugging**: Trace causation chains to understand event flow\n3. **Documentation**: Export graphs for architecture documentation\n4. **Monitoring**: Check health and memory status","ref":"repl.html#integration-with-development-workflow"},{"type":"extras","title":"Exit - Interactive REPL","doc":"Use any of these commands to exit:\n\n```\nexit\nquit\nq\n```\n\nOr press `Ctrl+D` (EOF).","ref":"repl.html#exit"},{"type":"extras","title":"See Also - Interactive REPL","doc":"- [Causation Tracking](causation.md) - Deep dive into causation concepts\n- [Temporal Queries](temporal_queries.md) - Time-based query patterns\n- [Event Sourcing](event_sourcing.md) - Core event sourcing patterns","ref":"repl.html#see-also"},{"type":"extras","title":"Subscriptions","doc":"# Subscriptions via Gateway\n\nSubscriptions enable real-time event delivery to consumers. This guide covers managing subscriptions and receiving events through the reckon-gater client API.","ref":"subscriptions.html"},{"type":"extras","title":"Overview - Subscriptions","doc":"![Subscription Flow](assets/subscription_flow.svg)\n\nThe gateway provides two ways to receive events:\n1. **Persistent Subscriptions** - Managed subscriptions with checkpointing\n2. **PubSub Channels** - Real-time event broadcasting","ref":"subscriptions.html#overview"},{"type":"extras","title":"Gateway Subscription API - Subscriptions","doc":"","ref":"subscriptions.html#gateway-subscription-api"},{"type":"extras","title":"Creating Subscriptions - Subscriptions","doc":"```erlang\n%% Create a subscription via gateway\nok = esdb_gater_api:save_subscription(\n    my_store,                    %% Store ID\n    stream,                      %% Type: stream | event_type | event_pattern | event_payload\n    <<\"order-123\">>,             %% Selector\n    <<\"order_handler\">>,         %% Subscription name\n    self(),                      %% Subscriber PID\n    #{}                          %% Options\n).\n```","ref":"subscriptions.html#creating-subscriptions"},{"type":"extras","title":"Subscription Types - Subscriptions","doc":"| Type | Selector | Use Case |\n|------|----------|----------|\n| `stream` | Stream ID | Single aggregate events |\n| `event_type` | Event type name | Cross-cutting concerns |\n| `event_pattern` | Wildcard pattern | Category projections |\n| `event_payload` | Match map | Conditional processing |\n\n#### Stream Subscription\n\n```erlang\n%% Subscribe to a single order's events\nok = esdb_gater_api:save_subscription(\n    my_store, stream, <<\"order-123\">>, <<\"order_handler\">>, self(), #{}\n).\n```\n\n#### Event Type Subscription\n\n```erlang\n%% Subscribe to all PaymentReceived events\nok = esdb_gater_api:save_subscription(\n    my_store, event_type, <<\"PaymentReceived\">>, <<\"payment_processor\">>, self(), #{}\n).\n```\n\n#### Pattern Subscription\n\n```erlang\n%% Subscribe to all order streams\nok = esdb_gater_api:save_subscription(\n    my_store, event_pattern, <<\"order-*\">>, <<\"order_projection\">>, self(), #{}\n).\n```\n\n#### Payload Subscription\n\n```erlang\n%% Subscribe to high-value orders\nok = esdb_gater_api:save_subscription(\n    my_store, event_payload, #{total => {gt, 10000}}, <<\"high_value_handler\">>, self(), #{}\n).\n```","ref":"subscriptions.html#subscription-types"},{"type":"extras","title":"Listing Subscriptions - Subscriptions","doc":"```erlang\n%% List all subscriptions\n{ok, Subscriptions} = esdb_gater_api:get_subscriptions(my_store).\n\n%% Each subscription contains:\n%% - type, selector, subscription_name\n%% - created_at, pool_size\n```","ref":"subscriptions.html#listing-subscriptions"},{"type":"extras","title":"Removing Subscriptions - Subscriptions","doc":"```erlang\n%% Remove a subscription\nok = esdb_gater_api:remove_subscription(\n    my_store, event_pattern, <<\"order-*\">>, <<\"order_projection\">>\n).\n```","ref":"subscriptions.html#removing-subscriptions"},{"type":"extras","title":"Acknowledging Events - Subscriptions","doc":"```erlang\n%% Acknowledge event processing (for at-least-once delivery)\nok = esdb_gater_api:ack_event(my_store, SubscriptionName, StreamId, EventVersion).\n```","ref":"subscriptions.html#acknowledging-events"},{"type":"extras","title":"PubSub Channels - Subscriptions","doc":"For real-time event delivery, use the gateway's built-in PubSub channels:","ref":"subscriptions.html#pubsub-channels"},{"type":"extras","title":"Available Channels - Subscriptions","doc":"| Channel | Priority | Purpose |\n|---------|----------|---------|\n| `esdb_channel_events` | high | Business events |\n| `esdb_channel_alerts` | critical | System alerts |\n| `esdb_channel_system` | normal | System notifications |\n| `esdb_channel_metrics` | normal | Performance metrics |","ref":"subscriptions.html#available-channels"},{"type":"extras","title":"Subscribing to Channels - Subscriptions","doc":"```erlang\n%% Subscribe to a topic pattern\nok = esdb_channel_server:subscribe(esdb_channel_events, <<\"order.*\">>, self()).\n\n%% Subscribe with wildcard\nok = esdb_channel_server:subscribe(esdb_channel_events, <<\"*\">>, self()).\n```","ref":"subscriptions.html#subscribing-to-channels"},{"type":"extras","title":"Receiving Channel Messages - Subscriptions","doc":"```erlang\n-module(my_event_handler).\n-behaviour(gen_server).\n\ninit([]) ->\n    %% Subscribe to order events\n    ok = esdb_channel_server:subscribe(esdb_channel_events, <<\"order.*\">>, self()),\n    {ok, #{}}.\n\nhandle_info({channel_message, esdb_channel_events, Topic, Event}, State) ->\n    %% Process the event\n    logger:info(\"Received ~s: ~p\", [Topic, Event]),\n    handle_event(Topic, Event),\n    {noreply, State}.\n\nhandle_event(<<\"order.placed\">>, Event) ->\n    %% Handle order placed\n    ok;\nhandle_event(<<\"order.shipped\">>, Event) ->\n    %% Handle order shipped\n    ok.\n```","ref":"subscriptions.html#receiving-channel-messages"},{"type":"extras","title":"Unsubscribing - Subscriptions","doc":"```erlang\n%% Unsubscribe from a topic\nok = esdb_channel_server:unsubscribe(esdb_channel_events, <<\"order.*\">>, self()).\n```","ref":"subscriptions.html#unsubscribing"},{"type":"extras","title":"Event Handler Patterns - Subscriptions","doc":"","ref":"subscriptions.html#event-handler-patterns"},{"type":"extras","title":"Basic Handler - Subscriptions","doc":"```erlang\n-module(order_handler).\n-behaviour(gen_server).\n-include_lib(\"reckon_gater/include/esdb_gater_types.hrl\").\n\n-export([start_link/1, init/1, handle_info/2]).\n\nstart_link(StoreId) ->\n    gen_server:start_link(?MODULE, [StoreId], []).\n\ninit([StoreId]) ->\n    %% Create subscription via gateway\n    ok = esdb_gater_api:save_subscription(\n        StoreId, event_pattern, <<\"order-*\">>, <<\"order_handler\">>, self(), #{}\n    ),\n\n    %% Also subscribe to PubSub for real-time delivery\n    ok = esdb_channel_server:subscribe(esdb_channel_events, <<\"order.*\">>, self()),\n\n    {ok, #{store_id => StoreId}}.\n\nhandle_info({channel_message, _, Topic, Event}, State) ->\n    handle_event(Event),\n    {noreply, State};\n\nhandle_info({event, Event}, State) ->\n    %% Direct subscription delivery\n    handle_event(Event),\n    {noreply, State}.\n\nhandle_event(#event{event_type = <<\"OrderPlaced\">>, data = Data}) ->\n    logger:info(\"Order placed: ~p\", [Data]);\nhandle_event(#event{event_type = <<\"OrderShipped\">>, data = Data}) ->\n    logger:info(\"Order shipped: ~p\", [Data]);\nhandle_event(_Event) ->\n    ok.\n```","ref":"subscriptions.html#basic-handler"},{"type":"extras","title":"Handler with Checkpointing - Subscriptions","doc":"```erlang\n-module(checkpointed_handler).\n-behaviour(gen_server).\n\ninit([StoreId]) ->\n    %% Load last processed position\n    LastPosition = load_checkpoint(StoreId),\n\n    %% Subscribe starting from checkpoint\n    ok = esdb_gater_api:save_subscription(\n        StoreId, event_pattern, <<\"order-*\">>, <<\"checkpointed_handler\">>, self(),\n        #{start_from => LastPosition}\n    ),\n\n    {ok, #{store_id => StoreId, last_position => LastPosition}}.\n\nhandle_info({event, #event{version = Version} = Event}, #{store_id := StoreId} = State) ->\n    %% Process the event\n    handle_event(Event),\n\n    %% Acknowledge and checkpoint\n    ok = esdb_gater_api:ack_event(StoreId, <<\"checkpointed_handler\">>, Event#event.stream_id, Version),\n    save_checkpoint(StoreId, Version),\n\n    {noreply, State#{last_position => Version}}.\n```","ref":"subscriptions.html#handler-with-checkpointing"},{"type":"extras","title":"Pool of Handlers - Subscriptions","doc":"```erlang\n-module(handler_pool).\n\nstart_pool(StoreId, PoolSize) ->\n    %% Create subscription\n    ok = esdb_gater_api:save_subscription(\n        StoreId, event_pattern, <<\"order-*\">>, <<\"handler_pool\">>, undefined,\n        #{pool_size => PoolSize}\n    ),\n\n    %% Start worker processes\n    [begin\n        {ok, Pid} = handler_worker:start_link(StoreId, N),\n        Pid\n    end || N <- lists:seq(1, PoolSize)].\n\n-module(handler_worker).\n\ninit([StoreId, WorkerId]) ->\n    %% Subscribe to PubSub for load-balanced delivery\n    ok = esdb_channel_server:subscribe(esdb_channel_events, <<\"*\">>, self()),\n    {ok, #{store_id => StoreId, worker_id => WorkerId}}.\n```","ref":"subscriptions.html#pool-of-handlers"},{"type":"extras","title":"Catch-Up Subscriptions - Subscriptions","doc":"Process historical events before receiving live events:\n\n```erlang\n%% Start from beginning (catch up on all history)\nok = esdb_gater_api:save_subscription(\n    my_store, event_pattern, <<\"order-*\">>, <<\"new_projection\">>, self(),\n    #{start_from => 0}\n).\n\n%% Resume from a specific position\nok = esdb_gater_api:save_subscription(\n    my_store, event_pattern, <<\"order-*\">>, <<\"resumed_projection\">>, self(),\n    #{start_from => 12345}\n).\n```","ref":"subscriptions.html#catch-up-subscriptions"},{"type":"extras","title":"Best Practices - Subscriptions","doc":"","ref":"subscriptions.html#best-practices"},{"type":"extras","title":"1. Idempotent Event Handling - Subscriptions","doc":"Events may be delivered more than once:\n\n```erlang\nhandle_event(#event{event_id = EventId} = Event) ->\n    case ets:lookup(processed_events, EventId) of\n        [{EventId, _}] ->\n            ok;  %% Already processed\n        [] ->\n            do_process_event(Event),\n            ets:insert(processed_events, {EventId, erlang:system_time()})\n    end.\n```","ref":"subscriptions.html#1-idempotent-event-handling"},{"type":"extras","title":"2. Monitor Subscription Lag - Subscriptions","doc":"Track how far behind your subscription is:\n\n```erlang\ncheck_lag(StoreId, StreamId, ProcessedVersion) ->\n    {ok, StreamVersion} = esdb_gater_api:get_version(StoreId, StreamId),\n    Lag = StreamVersion - ProcessedVersion,\n    case Lag > 1000 of\n        true -> logger:warning(\"Subscription lag: ~p events\", [Lag]);\n        false -> ok\n    end.\n```","ref":"subscriptions.html#2-monitor-subscription-lag"},{"type":"extras","title":"3. Graceful Shutdown - Subscriptions","doc":"Clean up subscriptions on shutdown:\n\n```erlang\nterminate(_Reason, #{store_id := StoreId}) ->\n    esdb_channel_server:unsubscribe(esdb_channel_events, <<\"order.*\">>, self()),\n    ok.\n```","ref":"subscriptions.html#3-graceful-shutdown"},{"type":"extras","title":"4. Handle Ordering - Subscriptions","doc":"Within a single stream, events are ordered. Across streams, no ordering guarantee:\n\n```erlang\n%% Events from stream \"order-123\" arrive in order\n%% But events from different streams may interleave\n```","ref":"subscriptions.html#4-handle-ordering"},{"type":"extras","title":"See Also - Subscriptions","doc":"- [Event Sourcing Guide](event_sourcing.md) - Foundation concepts\n- [Shared Types](shared_types.md) - Record definitions\n- [PubSub Channels](../README.md#pubsub-channels) - Channel reference\n\nFor server-side subscription internals, see the [reckon-db Subscriptions Guide](https://hexdocs.pm/reckon_db/subscriptions.html).","ref":"subscriptions.html#see-also"},{"type":"extras","title":"Snapshots","doc":"# Snapshots via Gateway\n\nSnapshots are periodic captures of aggregate state that optimize event replay performance. This guide covers accessing snapshots through the reckon-gater client API.","ref":"snapshots.html"},{"type":"extras","title":"Overview - Snapshots","doc":"Snapshots reduce the number of events needed to reconstruct aggregate state:\n\n![Snapshot Performance Comparison](assets/snapshots_comparison.svg)\n\n| Scenario | Recommendation |\n|----------|----------------|\n| Aggregates with < 100 events | Snapshots probably not needed |\n| Aggregates with 100-1000 events | Consider snapshots |\n| Aggregates with > 1000 events | Strongly recommended |\n| Frequent aggregate loading | Recommended |","ref":"snapshots.html#overview"},{"type":"extras","title":"Gateway Snapshot API - Snapshots","doc":"","ref":"snapshots.html#gateway-snapshot-api"},{"type":"extras","title":"Recording Snapshots - Snapshots","doc":"Save aggregate state at a specific version:\n\n```erlang\n%% Record a snapshot via gateway\nState = #{balance => 1000, status => active},\nok = esdb_gater_api:record_snapshot(\n    my_store,                    %% Store ID\n    my_source,                   %% Source ID (your application)\n    <<\"account-123\">>,           %% Stream ID\n    150,                         %% Version (event number)\n    State                        %% State to snapshot\n).\n```","ref":"snapshots.html#recording-snapshots"},{"type":"extras","title":"Reading Snapshots - Snapshots","doc":"Load the latest or a specific snapshot:\n\n```erlang\n%% Load the latest snapshot\ncase esdb_gater_api:read_snapshot(my_store, my_source, <<\"account-123\">>, latest) of\n    {ok, Snapshot} ->\n        Version = Snapshot#snapshot.version,\n        State = Snapshot#snapshot.data,\n        %% Replay events after the snapshot\n        {ok, Events} = esdb_gater_api:stream_forward(\n            my_store, <<\"account-123\">>, Version + 1, 10000\n        ),\n        FinalState = lists:foldl(fun apply_event/2, State, Events);\n    {error, not_found} ->\n        %% No snapshot, replay from beginning\n        {ok, AllEvents} = esdb_gater_api:stream_forward(\n            my_store, <<\"account-123\">>, 0, 10000\n        ),\n        lists:foldl(fun apply_event/2, initial_state(), AllEvents)\nend.\n\n%% Load snapshot at a specific version\n{ok, Snapshot} = esdb_gater_api:read_snapshot(\n    my_store, my_source, <<\"account-123\">>, 100\n).\n```","ref":"snapshots.html#reading-snapshots"},{"type":"extras","title":"Listing Snapshots - Snapshots","doc":"Get all snapshots for a stream:\n\n```erlang\n%% List all snapshots for a stream\n{ok, Snapshots} = esdb_gater_api:list_snapshots(my_store, my_source, <<\"account-123\">>).\n\n%% Returns list sorted by version (newest first)\n[\n    #snapshot{stream_id = <<\"account-123\">>, version = 150, ...},\n    #snapshot{stream_id = <<\"account-123\">>, version = 100, ...},\n    #snapshot{stream_id = <<\"account-123\">>, version = 50, ...}\n]\n```","ref":"snapshots.html#listing-snapshots"},{"type":"extras","title":"Deleting Snapshots - Snapshots","doc":"Remove old snapshots to save storage:\n\n```erlang\n%% Delete a specific snapshot\nok = esdb_gater_api:delete_snapshot(my_store, my_source, <<\"account-123\">>, 50).\n\n%% Delete old snapshots (keep only recent ones)\n{ok, Snapshots} = esdb_gater_api:list_snapshots(my_store, my_source, <<\"account-123\">>),\nOldSnapshots = lists:nthtail(3, Snapshots),  %% Keep 3 most recent\n[esdb_gater_api:delete_snapshot(my_store, my_source, S#snapshot.stream_id, S#snapshot.version)\n || S <- OldSnapshots].\n```","ref":"snapshots.html#deleting-snapshots"},{"type":"extras","title":"Client-Side Aggregate Pattern - Snapshots","doc":"A typical pattern for loading aggregates through the gateway:\n\n```erlang\n-module(account_client).\n-export([load/2, execute/3]).\n\n-include_lib(\"reckon_gater/include/esdb_gater_types.hrl\").\n\n-record(account, {\n    id,\n    balance = 0,\n    status = active,\n    version = 0\n}).\n\n-define(SNAPSHOT_THRESHOLD, 100).\n\n%% Load aggregate via gateway\nload(StoreId, AccountId) ->\n    StreamId = <<\"account-\", AccountId/binary>>,\n\n    %% Try to load from snapshot first\n    {InitialState, StartVersion} = case esdb_gater_api:read_snapshot(\n        StoreId, account_client, StreamId, latest\n    ) of\n        {ok, Snapshot} ->\n            {Snapshot#snapshot.data, Snapshot#snapshot.version + 1};\n        {error, not_found} ->\n            {#account{id = AccountId}, 0}\n    end,\n\n    %% Replay events after snapshot\n    case esdb_gater_api:stream_forward(StoreId, StreamId, StartVersion, 10000) of\n        {ok, Events} ->\n            FinalState = lists:foldl(fun apply_event/2, InitialState, Events),\n            NewVersion = case Events of\n                [] -> StartVersion;\n                _ -> (lists:last(Events))#event.version\n            end,\n            {ok, FinalState#account{version = NewVersion}};\n        {error, stream_not_found} when StartVersion =:= 0 ->\n            {ok, InitialState};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Execute command and persist events\nexecute(StoreId, AccountId, Command) ->\n    StreamId = <<\"account-\", AccountId/binary>>,\n\n    %% Load current state\n    {ok, Account} = load(StoreId, AccountId),\n\n    %% Execute command\n    case handle_command(Command, Account) of\n        {ok, Events} ->\n            %% Append events via gateway\n            {ok, NewVersion} = esdb_gater_api:append_events(\n                StoreId, StreamId, Events,\n                #{expected_version => Account#account.version}\n            ),\n\n            %% Apply events to get new state\n            NewState = lists:foldl(fun apply_event/2, Account, Events),\n\n            %% Maybe save snapshot\n            maybe_save_snapshot(StoreId, StreamId, NewState, NewVersion),\n\n            {ok, NewVersion, NewState};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Save snapshot if threshold reached\nmaybe_save_snapshot(StoreId, StreamId, State, Version)\n  when Version rem ?SNAPSHOT_THRESHOLD =:= 0, Version > 0 ->\n    ok = esdb_gater_api:record_snapshot(\n        StoreId, account_client, StreamId, Version, State\n    ),\n    logger:info(\"Saved snapshot for ~s at version ~p\", [StreamId, Version]);\nmaybe_save_snapshot(_StoreId, _StreamId, _State, _Version) ->\n    ok.\n\n%% Command handlers\nhandle_command({deposit, Amount}, #account{status = active} = Account)\n  when Amount > 0 ->\n    {ok, [#{\n        event_type => <<\"MoneyDeposited\">>,\n        data => #{amount => Amount, balance_after => Account#account.balance + Amount}\n    }]};\nhandle_command({deposit, _Amount}, #account{status = frozen}) ->\n    {error, account_frozen}.\n\n%% Event application\napply_event(#event{event_type = <<\"MoneyDeposited\">>, data = Data}, Account) ->\n    Amount = maps:get(amount, Data),\n    Account#account{balance = Account#account.balance + Amount};\napply_event(#event{event_type = <<\"MoneyWithdrawn\">>, data = Data}, Account) ->\n    Amount = maps:get(amount, Data),\n    Account#account{balance = Account#account.balance - Amount}.\n```","ref":"snapshots.html#client-side-aggregate-pattern"},{"type":"extras","title":"Snapshot Strategies - Snapshots","doc":"","ref":"snapshots.html#snapshot-strategies"},{"type":"extras","title":"Event-Count Based - Snapshots","doc":"Snapshot every N events (shown above):\n\n```erlang\n-define(SNAPSHOT_EVERY, 100).\n\nmaybe_snapshot(StoreId, StreamId, State, Version)\n  when Version rem ?SNAPSHOT_EVERY =:= 0 ->\n    esdb_gater_api:record_snapshot(StoreId, my_app, StreamId, Version, State);\nmaybe_snapshot(_, _, _, _) ->\n    ok.\n```","ref":"snapshots.html#event-count-based"},{"type":"extras","title":"Time-Based - Snapshots","doc":"Snapshot at regular intervals:\n\n```erlang\n-module(snapshot_scheduler).\n-behaviour(gen_server).\n\n-define(INTERVAL_MS, 60000).  %% Every minute\n\ninit([StoreId]) ->\n    timer:send_interval(?INTERVAL_MS, check_snapshots),\n    {ok, #{store_id => StoreId, aggregates => #{}}}.\n\nhandle_info(check_snapshots, #{store_id := StoreId, aggregates := Aggs} = State) ->\n    maps:foreach(fun(StreamId, {CurrentState, Version}) ->\n        case needs_snapshot(StoreId, StreamId, Version) of\n            true ->\n                esdb_gater_api:record_snapshot(\n                    StoreId, snapshot_scheduler, StreamId, Version, CurrentState\n                );\n            false ->\n                ok\n        end\n    end, Aggs),\n    {noreply, State}.\n\nneeds_snapshot(StoreId, StreamId, CurrentVersion) ->\n    case esdb_gater_api:read_snapshot(StoreId, snapshot_scheduler, StreamId, latest) of\n        {ok, #snapshot{version = V}} -> CurrentVersion - V > 100;\n        {error, not_found} -> CurrentVersion > 50\n    end.\n```","ref":"snapshots.html#time-based"},{"type":"extras","title":"Best Practices - Snapshots","doc":"","ref":"snapshots.html#best-practices"},{"type":"extras","title":"1. Keep Snapshots Small - Snapshots","doc":"Store only essential state:\n\n```erlang\n%% Good: Minimal state\nsnapshot_data(#account{} = A) ->\n    #{\n        balance => A#account.balance,\n        status => A#account.status\n    }.\n\n%% Bad: Including derived/cached data\nsnapshot_data(#account{} = A) ->\n    #{\n        balance => A#account.balance,\n        transaction_history => A#account.history,  %% Can be replayed\n        monthly_totals => A#account.totals         %% Derived data\n    }.\n```","ref":"snapshots.html#1-keep-snapshots-small"},{"type":"extras","title":"2. Version Your Snapshot Schema - Snapshots","doc":"Handle schema evolution:\n\n```erlang\n%% Save with version\nsave_state(State) ->\n    #{schema_version => 2, data => State}.\n\n%% Load with migration\nload_state(#{schema_version := 1, data := Data}) ->\n    %% Migrate v1 to v2\n    Data#{currency => <<\"USD\">>};\nload_state(#{schema_version := 2, data := Data}) ->\n    Data.\n```","ref":"snapshots.html#2-version-your-snapshot-schema"},{"type":"extras","title":"3. Cleanup Old Snapshots - Snapshots","doc":"Don't keep unlimited snapshots:\n\n```erlang\ncleanup_old_snapshots(StoreId, StreamId, KeepCount) ->\n    {ok, Snapshots} = esdb_gater_api:list_snapshots(StoreId, my_app, StreamId),\n    ToDelete = lists:nthtail(KeepCount, Snapshots),\n    [esdb_gater_api:delete_snapshot(StoreId, my_app, StreamId, S#snapshot.version)\n     || S <- ToDelete].\n```","ref":"snapshots.html#3-cleanup-old-snapshots"},{"type":"extras","title":"4. Monitor Performance - Snapshots","doc":"Track snapshot metrics:\n\n```erlang\nsave_with_metrics(StoreId, StreamId, Version, State) ->\n    Start = erlang:monotonic_time(microsecond),\n    ok = esdb_gater_api:record_snapshot(StoreId, my_app, StreamId, Version, State),\n    Duration = erlang:monotonic_time(microsecond) - Start,\n\n    telemetry:execute(\n        [my_app, snapshot, saved],\n        #{duration_us => Duration, size_bytes => byte_size(term_to_binary(State))},\n        #{stream_id => StreamId, version => Version}\n    ).\n```","ref":"snapshots.html#4-monitor-performance"},{"type":"extras","title":"See Also - Snapshots","doc":"- [Event Sourcing Guide](event_sourcing.md) - Foundation concepts\n- [Shared Types](shared_types.md) - Record definitions\n- [Subscriptions Guide](subscriptions.md) - Event delivery\n\nFor server-side snapshot internals, see the [reckon-db Snapshots Guide](https://hexdocs.pm/reckon_db/snapshots.html).","ref":"snapshots.html#see-also"},{"type":"extras","title":"Shared Types","doc":"# Shared Types\n\nreckon-gater defines common data structures used across the event sourcing ecosystem. These types provide a consistent interface between reckon-db, evoq, and adapter implementations.","ref":"shared_types.html"},{"type":"extras","title":"Including the Types - Shared Types","doc":"```erlang\n-include_lib(\"reckon_gater/include/esdb_gater_types.hrl\").\n```","ref":"shared_types.html#including-the-types"},{"type":"extras","title":"Event Record - Shared Types","doc":"The `#event{}` record represents an immutable fact stored in an event stream.\n\n```erlang\n-record(event, {\n    event_id          :: binary(),           %% Unique identifier (UUID)\n    event_type        :: binary(),           %% Type name (e.g., <<\"OrderPlaced\">>)\n    stream_id         :: binary(),           %% Stream this event belongs to\n    version           :: non_neg_integer(),  %% Position within stream (0-based)\n    data              :: map() | binary(),   %% Event payload (Erlang term)\n    metadata          :: map(),              %% Correlation, causation, user info\n    timestamp         :: integer(),          %% Millisecond timestamp\n    epoch_us          :: integer()           %% Microsecond epoch for ordering\n}).\n```","ref":"shared_types.html#event-record"},{"type":"extras","title":"Usage (Client-Side) - Shared Types","doc":"```erlang\n%% Creating an event for append via gateway\nEvent = #{\n    event_type => <<\"UserCreated\">>,\n    data => #{user_id => <<\"usr-123\">>, email => <<\"alice@example.com\">>},\n    metadata => #{correlation_id => <<\"req-456\">>}\n},\n{ok, Version} = esdb_gater_api:append_events(my_store, <<\"user-usr-123\">>, [Event]).\n\n%% Reading events returns #event{} records\n{ok, Events} = esdb_gater_api:stream_forward(my_store, <<\"user-usr-123\">>, 0, 100),\nlists:foreach(fun(#event{event_type = Type, data = Data}) ->\n    io:format(\"Event: ~s, Data: ~p~n\", [Type, Data])\nend, Events).\n```","ref":"shared_types.html#usage-client-side"},{"type":"extras","title":"Snapshot Record - Shared Types","doc":"The `#snapshot{}` record stores aggregate state at a specific version for fast recovery.\n\n```erlang\n-record(snapshot, {\n    stream_id  :: binary(),           %% Stream/aggregate identifier\n    version    :: non_neg_integer(),  %% Version at which snapshot was taken\n    data       :: map() | binary(),   %% Aggregate state (Erlang term)\n    metadata   :: map(),              %% Snapshot metadata\n    timestamp  :: integer()           %% When snapshot was created\n}).\n```","ref":"shared_types.html#snapshot-record"},{"type":"extras","title":"Usage (Client-Side) - Shared Types","doc":"```erlang\n%% Save a snapshot via gateway\nState = #{balance => 1000, status => active},\nok = esdb_gater_api:record_snapshot(my_store, my_source, <<\"account-123\">>, 50, State).\n\n%% Load latest snapshot\ncase esdb_gater_api:read_snapshot(my_store, my_source, <<\"account-123\">>, latest) of\n    {ok, #snapshot{version = V, data = State}} ->\n        %% Replay events from version V onwards\n        {ok, Events} = esdb_gater_api:stream_forward(my_store, <<\"account-123\">>, V, 1000),\n        FinalState = lists:foldl(fun apply_event/2, State, Events);\n    {error, not_found} ->\n        %% No snapshot, replay all events\n        rebuild_from_scratch(my_store, <<\"account-123\">>)\nend.\n```","ref":"shared_types.html#usage-client-side-1"},{"type":"extras","title":"Subscription Record - Shared Types","doc":"The `#subscription{}` record tracks subscription state for event delivery.\n\n```erlang\n-record(subscription, {\n    id                :: binary(),            %% Unique subscription ID\n    type              :: subscription_type(), %% stream | event_type | event_pattern | event_payload\n    selector          :: binary() | map(),    %% What to match\n    subscription_name :: binary(),            %% Human-readable name\n    subscriber_pid    :: pid() | undefined,   %% Process receiving events\n    created_at        :: integer(),           %% Creation timestamp\n    pool_size         :: pos_integer(),       %% Emitter pool size\n    checkpoint        :: non_neg_integer() | undefined,  %% Last processed position\n    options           :: map()                %% Additional options\n}).\n\n-type subscription_type() :: stream | event_type | event_pattern | event_payload.\n```","ref":"shared_types.html#subscription-record"},{"type":"extras","title":"Subscription Types - Shared Types","doc":"| Type | Selector | Description |\n|------|----------|-------------|\n| `stream` | Stream ID binary | Events from a specific stream |\n| `event_type` | Event type binary | Events of a specific type across all streams |\n| `event_pattern` | Pattern binary | Events matching a wildcard pattern |\n| `event_payload` | Match map | Events with matching payload fields |","ref":"shared_types.html#subscription-types"},{"type":"extras","title":"Usage (Client-Side) - Shared Types","doc":"```erlang\n%% Create a subscription via gateway\nok = esdb_gater_api:save_subscription(\n    my_store,\n    stream,                    %% Type\n    <<\"orders-*\">>,            %% Selector (pattern)\n    <<\"order_projection\">>,    %% Name\n    self(),                    %% Subscriber PID\n    #{}                        %% Options\n).\n\n%% List subscriptions\n{ok, Subscriptions} = esdb_gater_api:get_subscriptions(my_store).\n\n%% Remove a subscription\nok = esdb_gater_api:remove_subscription(my_store, stream, <<\"orders-*\">>, <<\"order_projection\">>).\n```","ref":"shared_types.html#usage-client-side-2"},{"type":"extras","title":"Version Constants - Shared Types","doc":"These constants control optimistic concurrency behavior:\n\n| Constant | Value | Behavior |\n|----------|-------|----------|\n| `?NO_STREAM` | -1 | Fails if stream exists |\n| `?ANY_VERSION` | -2 | Always appends |\n| `?STREAM_EXISTS` | -4 | Fails if stream doesn't exist |\n| `N >= 0` | N | Fails if current version != N |\n\nUsage with the gateway API:\n\n```erlang\n%% Append with version check via options\n{ok, Version} = esdb_gater_api:append_events(\n    my_store,\n    <<\"order-123\">>,\n    [Event],\n    #{expected_version => 4}  %% Fails if current version != 4\n).\n```","ref":"shared_types.html#version-constants"},{"type":"extras","title":"Append Result Record - Shared Types","doc":"The `#append_result{}` record provides details about a successful append operation.\n\n```erlang\n-record(append_result, {\n    version  :: non_neg_integer(),            %% New stream version\n    position :: non_neg_integer() | undefined, %% Global position (if applicable)\n    count    :: non_neg_integer()              %% Number of events appended\n}).\n```","ref":"shared_types.html#append-result-record"},{"type":"extras","title":"Error Types - Shared Types","doc":"```erlang\n-type append_error() ::\n    {wrong_expected_version, Expected :: integer(), Actual :: integer()} |\n    {stream_deleted, StreamId :: binary()} |\n    {timeout, Reason :: term()} |\n    {error, Reason :: term()}.\n\n-type read_error() ::\n    {stream_not_found, StreamId :: binary()} |\n    {timeout, Reason :: term()} |\n    {error, Reason :: term()}.\n```","ref":"shared_types.html#error-types"},{"type":"extras","title":"Ecosystem Usage - Shared Types","doc":"These types are used by:\n\n- **reckon-db**: Core event store implementation (server-side)\n- **reckon-gater**: Gateway API for distributed access (client-side)\n- **evoq**: CQRS/Event Sourcing framework\n- **reckon-evoq**: Adapter connecting evoq to reckon-db\n\nBy depending on reckon-gater for types, higher-level libraries avoid direct coupling to the core event store implementation.","ref":"shared_types.html#ecosystem-usage"},{"type":"extras","title":"See Also - Shared Types","doc":"- [Event Sourcing Guide](event_sourcing.md) - Event sourcing patterns\n- [Subscriptions Guide](subscriptions.md) - Subscription management\n- [Snapshots Guide](snapshots.md) - Snapshot strategies","ref":"shared_types.html#see-also"},{"type":"extras","title":"Capability Security","doc":"# Capability-Based Security\n\nThis guide explains the security model used in the reckon-db ecosystem and how to implement it in your applications.","ref":"capability_security.html"},{"type":"extras","title":"Prerequisites - Capability Security","doc":"Before reading this guide, you should understand:\n- Basic event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- Public-key cryptography basics (signing, verification)\n- The difference between authentication and authorization","ref":"capability_security.html#prerequisites"},{"type":"extras","title":"The Problem: Centralized Authorization Doesn't Scale - Capability Security","doc":"Traditional security models rely on a central authority:\n\n![Traditional Authorization](assets/auth_traditional.svg)\n\n**Problems with this approach:**\n- **Single point of failure** - If the auth server is down, nothing works\n- **Network dependency** - Every request requires a round-trip\n- **Partition intolerance** - Network splits break authorization\n- **Scalability bottleneck** - All requests funnel through one service\n\nIn a distributed mesh (like Macula), nodes may be temporarily disconnected. We need authorization that works **offline**.","ref":"capability_security.html#the-problem-centralized-authorization-doesn-t-scale"},{"type":"extras","title":"The Solution: Capability Tokens - Capability Security","doc":"Capability tokens are **self-proving** - they carry their own authorization:\n\n![Capability Authorization](assets/auth_capability.svg)\n\n**Benefits:**\n- **No central authority needed** - Any node can verify\n- **Works offline** - Verification is cryptographic, not network-based\n- **Delegatable** - Permissions can be passed with attenuation\n- **Time-bound** - Short TTLs limit damage from compromised tokens","ref":"capability_security.html#the-solution-capability-tokens"},{"type":"extras","title":"Architecture Overview - Capability Security","doc":"![Capability Security Architecture](assets/capability_architecture.svg)","ref":"capability_security.html#architecture-overview"},{"type":"extras","title":"Component Responsibilities - Capability Security","doc":"| Component | Location | Responsibility |\n|-----------|----------|----------------|\n| `esdb_identity` | Your Application | Generate keypairs, manage identities |\n| `esdb_capability` | Your Application | Create, sign, delegate, encode tokens |\n| `esdb_capability_verifier` | reckon-db Server | Verify signatures, check permissions |\n| `esdb_revocation` | reckon-db Server | Track revoked tokens |\n\n**Key insight:** Token *creation* happens in your application. Token *verification* happens on the reckon-db server. reckon-gater provides the types and helpers, but doesn't enforce security.\n\n---","ref":"capability_security.html#component-responsibilities"},{"type":"extras","title":"Part 1: Identity Management (Your Application) - Capability Security","doc":"Identities are Ed25519 keypairs. The public key is encoded as a DID (Decentralized Identifier).","ref":"capability_security.html#part-1-identity-management-your-application"},{"type":"extras","title":"Generate an Identity - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Create a new identity for your service/user\n%%--------------------------------------------------------------------\n\n-include_lib(\"reckon_gater/include/esdb_capability_types.hrl\").\n\n%% Generate a new Ed25519 keypair\nIdentity = esdb_identity:generate().\n\n%% The identity contains:\n%% - Public key (shareable)\n%% - Private key (keep secret!)\n%% - DID (public key encoded as did:key:z...)\n\n%% Get the DID for sharing with others\nDID = esdb_identity:did(Identity).\n%% => <<\"did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\">>\n```","ref":"capability_security.html#generate-an-identity"},{"type":"extras","title":"Store Identities Securely - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Persist identity across restarts\n%%--------------------------------------------------------------------\n\n%% NEVER store private keys in:\n%% - Version control\n%% - Environment variables (can leak in logs)\n%% - Unencrypted files\n\n%% DO store private keys in:\n%% - Hardware security modules (HSM)\n%% - Encrypted at rest with a master key\n%% - Secrets management (Vault, AWS Secrets Manager)\n\n%% Example: Load from encrypted file\nload_identity(Path, MasterKey) ->\n    {ok, Encrypted} = file:read_file(Path),\n    Decrypted = crypto:crypto_one_time(aes_256_gcm, MasterKey, Nonce, Encrypted, false),\n    {PubKey, PrivKey} = binary_to_term(Decrypted),\n    esdb_identity:from_keypair(PubKey, PrivKey).\n```","ref":"capability_security.html#store-identities-securely"},{"type":"extras","title":"Why DIDs? - Capability Security","doc":"DIDs (Decentralized Identifiers) are a W3C standard for self-sovereign identity. The `did:key` method encodes the public key directly in the identifier:\n\n```\ndid:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\n         \n          Base58btc encoded (multicodec prefix + Ed25519 public key)\n         Multibase prefix (z = base58btc)\n```\n\n**Benefits:**\n- Self-describing (contains the key itself)\n- No resolution needed (unlike did:web or did:eth)\n- Compact representation\n- Interoperable with UCAN ecosystem\n\n---","ref":"capability_security.html#why-dids"},{"type":"extras","title":"Part 2: Creating Capability Tokens (Your Application) - Capability Security","doc":"Capability tokens grant specific permissions on specific resources.","ref":"capability_security.html#part-2-creating-capability-tokens-your-application"},{"type":"extras","title":"Basic Token Creation - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (e.g., auth service)\n%% Purpose: Issue a token to a client/service\n%%--------------------------------------------------------------------\n\n%% Define what permissions to grant\nGrants = [\n    %% Can read any stream in the realm\n    esdb_capability:grant(<<\"esdb://myapp/stream/*\">>, ?ACTION_STREAM_READ),\n\n    %% Can append to order streams only\n    esdb_capability:grant(<<\"esdb://myapp/stream/orders-*\">>, ?ACTION_STREAM_APPEND)\n],\n\n%% Who is this token for? (their DID)\nAudience = <<\"did:key:z6MkClientDID...\">>,\n\n%% Create the capability (unsigned)\nCap = esdb_capability:create(MyIdentity, Audience, Grants, #{\n    ttl => 900  %% 15 minutes - keep it short!\n}),\n\n%% Sign with YOUR private key (proves you issued it)\nSignedCap = esdb_capability:sign(Cap, esdb_identity:private_key(MyIdentity)),\n\n%% Encode for transmission\nToken = esdb_capability:encode(SignedCap, jwt).\n%% => <<\"eyJhbGciOiJFZERTQSIsInR5cCI6IlVDQU4ifQ...\">>\n```","ref":"capability_security.html#basic-token-creation"},{"type":"extras","title":"Understanding Grants - Capability Security","doc":"A grant specifies WHAT (resource) and HOW (action):\n\n```erlang\n%% Grant structure\nesdb_capability:grant(Resource, Action)\n\n%% Resource: URI pattern for the resource\n%% Action: What operation is allowed\n```\n\n#### Resource URI Patterns\n\n| Pattern | Matches | Use Case |\n|---------|---------|----------|\n| `esdb://realm/stream/orders-123` | Exact stream | Single aggregate |\n| `esdb://realm/stream/orders-*` | Prefix match | All order streams |\n| `esdb://realm/stream/*` | All streams | Admin access |\n| `esdb://realm/channel/events/*` | All topics | Full channel access |\n| `esdb://realm/channel/events/orders.*` | Topic prefix | Order events only |\n\n#### Available Actions\n\n| Constant | Wire Format | Description |\n|----------|-------------|-------------|\n| `?ACTION_STREAM_APPEND` | `stream/append` | Write events to streams |\n| `?ACTION_STREAM_READ` | `stream/read` | Read events from streams |\n| `?ACTION_STREAM_SUBSCRIBE` | `stream/subscribe` | Subscribe to stream changes |\n| `?ACTION_CHANNEL_PUBLISH` | `channel/publish` | Publish to PubSub channel |\n| `?ACTION_CHANNEL_SUBSCRIBE` | `channel/subscribe` | Subscribe to PubSub topic |\n| `?ACTION_SNAPSHOT_WRITE` | `snapshot/write` | Write snapshots |\n| `?ACTION_SNAPSHOT_READ` | `snapshot/read` | Read snapshots |\n| `?ACTION_ADMIN_ALL` | `*` | All actions (use sparingly!) |\n\n---","ref":"capability_security.html#understanding-grants"},{"type":"extras","title":"Part 3: Delegation (Your Application) - Capability Security","doc":"Delegation allows passing permissions to others **with attenuation** (reducing scope).","ref":"capability_security.html#part-3-delegation-your-application"},{"type":"extras","title":"Why Delegation Matters - Capability Security","doc":"Consider a microservices architecture where each service delegates to the next with **reduced** permissions:\n\n![Delegation Chain](assets/delegation_chain.svg)","ref":"capability_security.html#why-delegation-matters"},{"type":"extras","title":"Delegation Rules - Capability Security","doc":"1. **Attenuation only** - You can reduce permissions, never expand\n2. **TTL inheritance** - Child TTL cannot exceed parent's remaining time\n3. **Proof chain** - Child includes cryptographic reference to parent\n4. **Signature required** - You sign the delegation with YOUR key","ref":"capability_security.html#delegation-rules"},{"type":"extras","title":"Delegation Example - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (Order Service)\n%% Purpose: Delegate reduced permissions to Payment Service\n%%--------------------------------------------------------------------\n\n%% We received Token A with: stream/* read+append\n%% We want to give Payment Service: orders-*/read only\n\nWorkerGrants = [\n    esdb_capability:grant(<<\"esdb://myapp/stream/orders-*\">>, ?ACTION_STREAM_READ)\n    %% Note: NO append permission - attenuation!\n],\n\n%% Delegate from our token to the worker\nWorkerCap = esdb_capability:delegate(\n    OurSignedToken,        %% Parent token (must be signed)\n    PaymentServiceDID,     %% Who we're delegating to\n    WorkerGrants           %% Reduced permissions\n),\n\n%% Sign with OUR key (proves WE delegated it)\nSignedWorkerCap = esdb_capability:sign(WorkerCap, esdb_identity:private_key(OurIdentity)).\n```","ref":"capability_security.html#delegation-example"},{"type":"extras","title":"Invalid Delegations - Capability Security","doc":"These will fail verification on the server:\n\n```erlang\n%% Parent grants: stream/orders-* with read\n%% INVALID: trying to add append (not in parent)\nBadGrants = [\n    esdb_capability:grant(<<\"esdb://myapp/stream/orders-*\">>, ?ACTION_STREAM_APPEND)\n].\n\n%% Parent grants: stream/orders-* with read\n%% INVALID: trying to access users-* (outside scope)\nBadGrants = [\n    esdb_capability:grant(<<\"esdb://myapp/stream/users-*\">>, ?ACTION_STREAM_READ)\n].\n```\n\n---","ref":"capability_security.html#invalid-delegations"},{"type":"extras","title":"Part 4: Using Tokens (Your Application  reckon-db) - Capability Security","doc":"When making requests, include the token. The gater routes it to reckon-db for verification.","ref":"capability_security.html#part-4-using-tokens-your-application-reckon-db"},{"type":"extras","title":"Stream Operations with Tokens - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Append events using capability token\n%%--------------------------------------------------------------------\n\n%% Include token in request (future API enhancement)\n%% Currently, tokens are used primarily for PubSub channels\n\nEvents = [#{event_type => <<\"OrderCreated\">>, data => #{...}}],\n{ok, Version} = esdb_gater_api:append_events(my_store, <<\"orders-123\">>, Events).\n```","ref":"capability_security.html#stream-operations-with-tokens"},{"type":"extras","title":"PubSub Channel Operations - Capability Security","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Publish/subscribe with capability authorization\n%%--------------------------------------------------------------------\n\n%% Create a capability for publishing\nGrants = [\n    esdb_capability:grant(\n        <<\"esdb://myapp/channel/esdb_channel_events/*\">>,\n        ?ACTION_CHANNEL_PUBLISH\n    )\n],\nCap = esdb_capability:create(Issuer, Audience, Grants, #{ttl => 900}),\nSignedCap = esdb_capability:sign(Cap, esdb_identity:private_key(Issuer)),\nToken = esdb_capability:encode(SignedCap, binary),\n\n%% Publish with capability token\nok = esdb_channel:publish(esdb_channel_events, <<\"orders.created\">>, Event, Token).\n\n%% Subscribe with capability token\nok = esdb_channel:subscribe(esdb_channel_events, <<\"orders.*\">>, self(), Token).\n```\n\n---","ref":"capability_security.html#pubsub-channel-operations"},{"type":"extras","title":"Part 5: Token Verification (reckon-db Server) - Capability Security","doc":"**You don't write this code** - it runs automatically on the reckon-db server.","ref":"capability_security.html#part-5-token-verification-reckon-db-server"},{"type":"extras","title":"What the Server Checks - Capability Security","doc":"1. **Signature valid?** - Cryptographically verify using issuer's public key\n2. **Not expired?** - Check `exp` timestamp against current time\n3. **Not before valid?** - Check `nbf` timestamp\n4. **Not revoked?** - Check against revocation list\n5. **Resource matches?** - Does the grant cover the requested resource?\n6. **Action allowed?** - Does the grant include the requested action?\n7. **Delegation valid?** - If delegated, verify parent chain","ref":"capability_security.html#what-the-server-checks"},{"type":"extras","title":"Verification Flow - Capability Security","doc":"![Token Verification Flow](assets/verification_flow.svg)\n\n---","ref":"capability_security.html#verification-flow"},{"type":"extras","title":"Part 6: Token Formats - Capability Security","doc":"","ref":"capability_security.html#part-6-token-formats"},{"type":"extras","title":"JWT Format (Interoperable) - Capability Security","doc":"```erlang\nToken = esdb_capability:encode(Cap, jwt).\n%% => <<\"eyJhbGciOiJFZERTQSIsInR5cCI6IlVDQU4ifQ.eyJpc3MiOiJkaWQ6...\">>\n```\n\n**Use when:**\n- Communicating with web clients (JavaScript)\n- Crossing system boundaries\n- Debugging (JWTs are human-readable when decoded)\n- Interoperating with other UCAN-compatible systems","ref":"capability_security.html#jwt-format-interoperable"},{"type":"extras","title":"Erlang Binary Format (Fast) - Capability Security","doc":"```erlang\nToken = esdb_capability:encode(Cap, binary).\n%% => <<131, 104, 12, 100, ...>>\n```\n\n**Use when:**\n- Internal mesh communication\n- Maximum performance is critical\n- Both ends are Erlang/Elixir\n\nDecoding auto-detects format:\n\n```erlang\n{ok, Cap} = esdb_capability:decode(Token).  %% Works for both formats\n```\n\n---","ref":"capability_security.html#erlang-binary-format-fast"},{"type":"extras","title":"Common Pitfalls - Capability Security","doc":"","ref":"capability_security.html#common-pitfalls"},{"type":"extras","title":"1. Token Lifetime Too Long - Capability Security","doc":"```erlang\n%% BAD: Token valid for 30 days\nCap = esdb_capability:create(Iss, Aud, Grants, #{ttl => 30 * 24 * 60 * 60}).\n\n%% GOOD: Short-lived tokens, refresh as needed\nCap = esdb_capability:create(Iss, Aud, Grants, #{ttl => 900}).  %% 15 minutes\n```\n\n**Why:** If a token is compromised, damage is limited to its lifetime.","ref":"capability_security.html#1-token-lifetime-too-long"},{"type":"extras","title":"2. Overly Broad Grants - Capability Security","doc":"```erlang\n%% BAD: Admin access for everything\nGrants = [esdb_capability:grant(<<\"esdb://myapp/*\">>, ?ACTION_ADMIN_ALL)].\n\n%% GOOD: Minimum necessary permissions\nGrants = [esdb_capability:grant(<<\"esdb://myapp/stream/orders-*\">>, ?ACTION_STREAM_READ)].\n```\n\n**Why:** Principle of least privilege limits blast radius.","ref":"capability_security.html#2-overly-broad-grants"},{"type":"extras","title":"3. Storing Private Keys in Code - Capability Security","doc":"```erlang\n%% BAD: Hardcoded private key\nPrivKey = <<16#deadbeef:256>>.\n\n%% GOOD: Load from secure storage at runtime\n{ok, PrivKey} = secrets_manager:get(<<\"my-service-private-key\">>).\n```","ref":"capability_security.html#3-storing-private-keys-in-code"},{"type":"extras","title":"4. Ignoring Token Validation Errors - Capability Security","doc":"```erlang\n%% BAD: Ignoring errors\nesdb_channel:publish(Channel, Topic, Msg, Token).\n\n%% GOOD: Handle authorization failures\ncase esdb_channel:publish(Channel, Topic, Msg, Token) of\n    ok -> ok;\n    {error, {unauthorized, Reason}} ->\n        logger:warning(\"Publish denied: ~p\", [Reason]),\n        {error, forbidden}\nend.\n```\n\n---","ref":"capability_security.html#4-ignoring-token-validation-errors"},{"type":"extras","title":"Security Considerations - Capability Security","doc":"","ref":"capability_security.html#security-considerations"},{"type":"extras","title":"Short Token Lifetimes - Capability Security","doc":"Default TTL is 15 minutes. This is intentional:\n\n- Limits exposure if token is leaked\n- Forces regular re-authentication\n- Revocation becomes less critical (tokens expire quickly)","ref":"capability_security.html#short-token-lifetimes"},{"type":"extras","title":"Key Rotation - Capability Security","doc":"Rotate identity keys periodically:\n\n1. Generate new keypair\n2. Start issuing tokens with new key\n3. Keep old key for verification until old tokens expire\n4. Retire old key","ref":"capability_security.html#key-rotation"},{"type":"extras","title":"Revocation Strategy - Capability Security","doc":"For LAN clusters (typical reckon-db deployment), short TTLs are usually sufficient. Emergency revocation is available via `esdb_revocation` in reckon-db:\n\n```erlang\n%% Server-side (reckon-db) - emergency revocation\nesdb_revocation:revoke(TokenCID).\n```\n\n---","ref":"capability_security.html#revocation-strategy"},{"type":"extras","title":"API Reference - Capability Security","doc":"","ref":"capability_security.html#api-reference"},{"type":"extras","title":"esdb_identity (Your Application) - Capability Security","doc":"| Function | Description |\n|----------|-------------|\n| `generate()` | Generate new Ed25519 identity |\n| `from_keypair(Pub, Priv)` | Create from existing keys |\n| `from_public_key(Pub)` | Create from public key only (for verification) |\n| `did(Identity)` | Get DID string |\n| `public_key(Identity)` | Get 32-byte public key |\n| `private_key(Identity)` | Get 32-byte private key |\n| `public_key_from_did(DID)` | Extract public key from DID |","ref":"capability_security.html#esdb_identity-your-application"},{"type":"extras","title":"esdb_capability (Your Application) - Capability Security","doc":"| Function | Description |\n|----------|-------------|\n| `create(Iss, Aud, Grants)` | Create unsigned capability |\n| `create(Iss, Aud, Grants, Opts)` | Create with options (ttl, nbf) |\n| `sign(Cap, PrivKey)` | Sign with Ed25519 private key |\n| `delegate(Parent, Aud, Grants)` | Delegate with attenuation |\n| `encode(Cap, jwt \\| binary)` | Encode for transmission |\n| `decode(Token)` | Decode from any format |\n| `grant(Resource, Action)` | Create a grant tuple |\n| `is_expired(Cap)` | Check if token has expired |","ref":"capability_security.html#esdb_capability-your-application"},{"type":"extras","title":"esdb_capability_verifier (reckon-db Server) - Capability Security","doc":"| Function | Description |\n|----------|-------------|\n| `verify(Token)` | Verify signature and time bounds |\n| `authorize(Token, Resource, Action)` | Full authorization check |\n\n---","ref":"capability_security.html#esdb_capability_verifier-reckon-db-server"},{"type":"extras","title":"Further Reading - Capability Security","doc":"- [UCAN Specification](https://github.com/ucan-wg/spec) - The standard we follow\n- [DID Key Method](https://w3c-ccg.github.io/did-method-key/) - How DIDs encode keys\n- [Ed25519 Signatures](https://ed25519.cr.yp.to/) - The cryptography behind it\n- [Capability-Based Security (Wikipedia)](https://en.wikipedia.org/wiki/Capability-based_security) - Conceptual background","ref":"capability_security.html#further-reading"},{"type":"extras","title":"Temporal Queries","doc":"# Temporal Queries\n\nThis guide explains how to query events by timestamp, enabling point-in-time reconstruction and historical analysis.","ref":"temporal_queries.html"},{"type":"extras","title":"Prerequisites - Temporal Queries","doc":"Before reading this guide, you should understand:\n- Event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- How events are stored with versions and timestamps\n- Aggregate reconstruction from events","ref":"temporal_queries.html#prerequisites"},{"type":"extras","title":"The Problem: Version Numbers Aren't Always Enough - Temporal Queries","doc":"In event sourcing, you typically read events by version number:\n\n```erlang\n%% \"Give me events 0-100 from this stream\"\n{ok, Events} = esdb_gater_api:stream_forward(Store, Stream, 0, 100).\n```\n\nBut sometimes you need to answer **time-based** questions:\n\n- \"What was the account balance at end of Q3?\" (compliance/auditing)\n- \"Show me all events during the outage window\" (debugging)\n- \"Reconstruct state as of the backup timestamp\" (disaster recovery)\n\nVersion numbers don't help here because you don't know which version corresponds to which time.","ref":"temporal_queries.html#the-problem-version-numbers-aren-t-always-enough"},{"type":"extras","title":"The Solution: Temporal Queries - Temporal Queries","doc":"Temporal queries filter events by their `epoch_us` timestamp (microseconds since Unix epoch):\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Query events by timestamp instead of version\n%%--------------------------------------------------------------------\n\n%% Read all events up to a specific moment\n{ok, Events} = esdb_gater_api:read_until(my_store, <<\"account-123\">>, Timestamp).\n```","ref":"temporal_queries.html#the-solution-temporal-queries"},{"type":"extras","title":"How It Works - Temporal Queries","doc":"```\nEvents in stream:\n\n v0        v1        v2        v3        v4        v5        v6   \n 10:00     10:15     10:30     10:45     11:00     11:15     11:30\n\n                           \n                           \n              read_until(10:45) returns v0, v1, v2, v3\n```\n\n---","ref":"temporal_queries.html#how-it-works"},{"type":"extras","title":"Where Does This Code Run? - Temporal Queries","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Query events by timestamp | Your Application | `esdb_gater_api` |\n| Aggregate reconstruction | Your Application | Your aggregate logic |\n| Timestamp storage | reckon-db Server | Automatic with each event |\n\n---","ref":"temporal_queries.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Temporal Queries","doc":"","ref":"temporal_queries.html#api-reference"},{"type":"extras","title":"Read Until - Temporal Queries","doc":"Read all events up to (and including) a timestamp:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Get events up to a specific point in time\n%%--------------------------------------------------------------------\n\n%% Basic usage - timestamp in microseconds since Unix epoch\nTimestamp = 1703001600000000,  %% Dec 19, 2025 12:00:00 UTC\n{ok, Events} = esdb_gater_api:read_until(my_store, <<\"account-123\">>, Timestamp).\n\n%% With options\n{ok, Events} = esdb_gater_api:read_until(my_store, <<\"account-123\">>, Timestamp, #{\n    max_count => 1000       %% Limit number of events returned\n}).\n```","ref":"temporal_queries.html#read-until"},{"type":"extras","title":"Read Range - Temporal Queries","doc":"Read events within a time window:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Get events between two timestamps\n%%--------------------------------------------------------------------\n\nFromTimestamp = 1703001600000000,  %% Dec 19, 2025 12:00:00 UTC\nToTimestamp = 1703005200000000,    %% Dec 19, 2025 13:00:00 UTC\n\n{ok, Events} = esdb_gater_api:read_range(\n    my_store,\n    <<\"account-123\">>,\n    FromTimestamp,\n    ToTimestamp\n).\n```","ref":"temporal_queries.html#read-range"},{"type":"extras","title":"Version at Timestamp - Temporal Queries","doc":"Get the stream version at a specific point in time (without fetching events):\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Find what version the stream was at a given time\n%%--------------------------------------------------------------------\n\n{ok, Version} = esdb_gater_api:version_at(my_store, <<\"account-123\">>, Timestamp).\n%% => {ok, 42}\n\n%% Useful for:\n%% - Loading a snapshot at that version\n%% - Understanding stream growth over time\n%% - Correlating with external systems\n```\n\n---","ref":"temporal_queries.html#version-at-timestamp"},{"type":"extras","title":"Use Cases - Temporal Queries","doc":"","ref":"temporal_queries.html#use-cases"},{"type":"extras","title":"1. Point-in-Time Aggregate Reconstruction - Temporal Queries","doc":"Rebuild an aggregate's state as it was at a specific moment:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Answer \"what was the state at time X?\"\n%%--------------------------------------------------------------------\n\n-module(my_aggregate).\n\n%% Reconstruct state at a specific timestamp\nreconstruct_at(StoreId, StreamId, Timestamp) ->\n    %% Get all events up to that moment\n    {ok, Events} = esdb_gater_api:read_until(StoreId, StreamId, Timestamp),\n\n    %% Fold them into state (same as normal reconstruction)\n    State = reckon_db_aggregator:foldl(Events),\n\n    %% Finalize tagged values\n    reckon_db_aggregator:finalize(State).\n\n%% Example usage:\n%% EndOfQ3 = timestamp_for({{2025, 9, 30}, {23, 59, 59}}),\n%% State = my_aggregate:reconstruct_at(my_store, <<\"account-123\">>, EndOfQ3),\n%% Balance = maps:get(balance, State).\n```","ref":"temporal_queries.html#1-point-in-time-aggregate-reconstruction"},{"type":"extras","title":"2. Compliance and Auditing - Temporal Queries","doc":"Answer regulatory questions about historical state:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Generate compliance reports for a specific date\n%%--------------------------------------------------------------------\n\n-module(compliance_report).\n\ngenerate_eod_report(StoreId, Date) ->\n    %% End of day timestamp\n    EndOfDay = end_of_day_timestamp(Date),\n\n    %% Get all account streams\n    {ok, Streams} = esdb_gater_api:get_streams(StoreId),\n    AccountStreams = [S || S <- Streams, is_account_stream(S)],\n\n    %% Reconstruct each account at end of day\n    Reports = lists:map(\n        fun(StreamId) ->\n            State = reconstruct_at(StoreId, StreamId, EndOfDay),\n            #{\n                account_id => StreamId,\n                balance => maps:get(balance, State, 0),\n                as_of => Date\n            }\n        end,\n        AccountStreams\n    ),\n\n    #{date => Date, accounts => Reports}.\n\nend_of_day_timestamp(Date) ->\n    DateTime = {Date, {23, 59, 59}},\n    GregorianSecs = calendar:datetime_to_gregorian_seconds(DateTime),\n    UnixSecs = GregorianSecs - 62167219200,  %% Gregorian to Unix offset\n    UnixSecs * 1000000.  %% Convert to microseconds\n```","ref":"temporal_queries.html#2-compliance-and-auditing"},{"type":"extras","title":"3. Incident Investigation - Temporal Queries","doc":"Examine what happened during a specific time window:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Debug by examining events during an incident\n%%--------------------------------------------------------------------\n\n-module(incident_debug).\n\ninvestigate(StoreId, StreamPattern, IncidentStart, IncidentEnd) ->\n    %% Get events during the incident window\n    {ok, Events} = esdb_gater_api:read_range(\n        StoreId,\n        StreamPattern,\n        IncidentStart,\n        IncidentEnd\n    ),\n\n    %% Analyze what happened\n    #{\n        event_count => length(Events),\n        event_types => count_by_type(Events),\n        timeline => build_timeline(Events),\n        first_event => hd(Events),\n        last_event => lists:last(Events)\n    }.\n\ncount_by_type(Events) ->\n    lists:foldl(\n        fun(#{event_type := Type}, Acc) ->\n            maps:update_with(Type, fun(N) -> N + 1 end, 1, Acc)\n        end,\n        #{},\n        Events\n    ).\n```\n\n---","ref":"temporal_queries.html#3-incident-investigation"},{"type":"extras","title":"Working with Timestamps - Temporal Queries","doc":"reckon-db uses **microseconds since Unix epoch** for all timestamps.","ref":"temporal_queries.html#working-with-timestamps"},{"type":"extras","title":"Getting Current Time - Temporal Queries","doc":"```erlang\nNow = erlang:system_time(microsecond).\n%% => 1703001600000000\n```","ref":"temporal_queries.html#getting-current-time"},{"type":"extras","title":"Converting from Calendar Datetime - Temporal Queries","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Helper to convert Erlang datetime to microseconds\n%%--------------------------------------------------------------------\n\ndatetime_to_micros({{Y, M, D}, {H, Min, S}}) ->\n    GregorianSecs = calendar:datetime_to_gregorian_seconds({{Y, M, D}, {H, Min, S}}),\n    UnixSecs = GregorianSecs - 62167219200,  %% Gregorian epoch to Unix epoch\n    UnixSecs * 1000000.\n\n%% Example:\n%% Timestamp = datetime_to_micros({{2025, 12, 19}, {12, 0, 0}}).\n%% => 1703001600000000\n```","ref":"temporal_queries.html#converting-from-calendar-datetime"},{"type":"extras","title":"Converting from ISO 8601 String - Temporal Queries","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Parse ISO 8601 timestamp\n%%--------------------------------------------------------------------\n\niso8601_to_micros(IsoString) ->\n    %% \"2025-12-19T12:00:00Z\"\n    [DatePart, TimePart] = binary:split(IsoString, <<\"T\">>),\n    [Y, M, D] = [binary_to_integer(X) || X <- binary:split(DatePart, <<\"-\">>, [global])],\n    [H, Min, SecZ] = binary:split(TimePart, <<\":\">>, [global]),\n    S = binary_to_integer(binary:part(SecZ, 0, 2)),\n    datetime_to_micros({{Y, M, D}, {H, Min, S}}).\n```\n\n---","ref":"temporal_queries.html#converting-from-iso-8601-string"},{"type":"extras","title":"Performance Considerations - Temporal Queries","doc":"","ref":"temporal_queries.html#performance-considerations"},{"type":"extras","title":"Temporal Queries vs. Version Queries - Temporal Queries","doc":"| Query Type | Use When | Performance |\n|------------|----------|-------------|\n| Version-based | You know the version range | Fastest (direct index) |\n| Temporal | You need time-based filtering | Slower (scan + filter) |","ref":"temporal_queries.html#temporal-queries-vs-version-queries"},{"type":"extras","title":"Optimization Tips - Temporal Queries","doc":"1. **Use max_count** - Limit results for large streams:\n   ```erlang\n   esdb_gater_api:read_until(Store, Stream, Ts, #{max_count => 1000}).\n   ```\n\n2. **Combine with snapshots** - For aggregate reconstruction, load snapshot first:\n   ```erlang\n   {ok, Snapshot} = esdb_gater_api:read_snapshot(Store, Source, Stream, Version),\n   SnapshotTime = maps:get(timestamp, Snapshot),\n   {ok, NewEvents} = esdb_gater_api:read_range(Store, Stream, SnapshotTime, TargetTime).\n   ```\n\n3. **Index awareness** - Events are sorted by version, not timestamp. Temporal queries may scan more events than version queries.\n\n---","ref":"temporal_queries.html#optimization-tips"},{"type":"extras","title":"Common Pitfalls - Temporal Queries","doc":"","ref":"temporal_queries.html#common-pitfalls"},{"type":"extras","title":"1. Wrong Timestamp Units - Temporal Queries","doc":"```erlang\n%% BAD: Seconds instead of microseconds\nTimestamp = 1703001600.  %% This is seconds!\n\n%% GOOD: Microseconds\nTimestamp = 1703001600000000.  %% Correct\n%% Or use:\nTimestamp = erlang:system_time(microsecond).\n```","ref":"temporal_queries.html#1-wrong-timestamp-units"},{"type":"extras","title":"2. Timezone Confusion - Temporal Queries","doc":"```erlang\n%% Timestamps are always UTC internally\n%% Convert from local time carefully:\n\n%% BAD: Using local time directly\nLocalTime = calendar:local_time(),\nMicros = datetime_to_micros(LocalTime).  %% Wrong if not UTC!\n\n%% GOOD: Convert to UTC first\nUTCTime = calendar:local_time_to_universal_time_dst(LocalTime),\nMicros = datetime_to_micros(hd(UTCTime)).\n```","ref":"temporal_queries.html#2-timezone-confusion"},{"type":"extras","title":"3. Clock Skew in Distributed Systems - Temporal Queries","doc":"Events from different nodes may have slightly different timestamps due to clock skew.\n\n```erlang\n%% Be aware that events may not be perfectly ordered by timestamp\n%% across nodes. Version ordering is authoritative.\n```\n\n---","ref":"temporal_queries.html#3-clock-skew-in-distributed-systems"},{"type":"extras","title":"When NOT to Use Temporal Queries - Temporal Queries","doc":"- **Real-time subscriptions** - Use subscriptions instead, not polling with timestamps\n- **Simple \"latest state\"** - Just read all events by version\n- **High-frequency queries** - Version-based queries are more efficient\n- **Sub-millisecond precision** - Timestamp resolution is limited\n\n---","ref":"temporal_queries.html#when-not-to-use-temporal-queries"},{"type":"extras","title":"Related Guides - Temporal Queries","doc":"- [Event Sourcing](event_sourcing.md) - Core concepts\n- [Snapshots](snapshots.md) - Optimize reconstruction with snapshots\n- [Scavenging](scavenging.md) - Remove old events (uses timestamps)","ref":"temporal_queries.html#related-guides"},{"type":"extras","title":"Scavenging","doc":"# Scavenging\n\nThis guide explains how to remove old events from streams to manage storage growth while preserving the ability to reconstruct current state via snapshots.","ref":"scavenging.html"},{"type":"extras","title":"Prerequisites - Scavenging","doc":"Before reading this guide, you should understand:\n- Event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- Snapshots and their role in state reconstruction ([Snapshots Guide](snapshots.md))\n- The immutable nature of event logs and why deletion requires special care","ref":"scavenging.html#prerequisites"},{"type":"extras","title":"The Problem: Unbounded Storage Growth - Scavenging","doc":"In event sourcing, events are immutable and never deleted by default. Over time, this leads to:\n\n- **Storage costs** - Event logs grow indefinitely\n- **Read performance** - More events to scan for reconstruction\n- **Compliance challenges** - Some regulations require data deletion\n\nBut you can't just delete events randomlythat would break state reconstruction.","ref":"scavenging.html#the-problem-unbounded-storage-growth"},{"type":"extras","title":"The Solution: Scavenging - Scavenging","doc":"Scavenging safely removes old events by:\n\n1. **Requiring a snapshot** - Ensures state can still be reconstructed\n2. **Preserving recent events** - Keeps events newer than the snapshot\n3. **Dry run preview** - Shows what would be deleted before executing\n\n```\nBefore scavenging:\n\n v0   v1   v2   ... v500 ... v1000 v1001 v1002 ... v1500        \n                                                              \n     Old events            Newer events                       \n\n                       \n                  Snapshot at v500\n\nAfter scavenging (before=v500):\n\n              [deleted]     v500 v501 ... v1000 v1001 ... v1500 \n                                                                \n                        Snapshot preserved                       \n\n```\n\n---","ref":"scavenging.html#the-solution-scavenging"},{"type":"extras","title":"Where Does This Code Run? - Scavenging","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Scavenge API calls | Your Application | `esdb_gater_api` |\n| Snapshot creation | Your Application | `esdb_gater_api` |\n| Event deletion | reckon-db Server | Internal |\n| Archival (optional) | reckon-db Server | `reckon_db_archive_*` |\n\n---","ref":"scavenging.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Scavenging","doc":"","ref":"scavenging.html#api-reference"},{"type":"extras","title":"Scavenge a Stream - Scavenging","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Remove events older than a timestamp from a stream\n%%--------------------------------------------------------------------\n\n%% Calculate cutoff: 30 days ago\nThirtyDaysAgo = erlang:system_time(microsecond) - (30 * 24 * 60 * 60 * 1000000),\n\n%% Scavenge the stream\n{ok, Result} = esdb_gater_api:scavenge(my_store, <<\"orders-123\">>, #{\n    before => ThirtyDaysAgo,\n    require_snapshot => true  %% Safety: only scavenge if snapshot exists\n}).\n\n%% Result shows what was deleted\n#{\n    deleted_count => 1523,\n    oldest_remaining => 1703001600000000,\n    snapshot_version => 1500\n}\n```","ref":"scavenging.html#scavenge-a-stream"},{"type":"extras","title":"Scavenge Matching Streams - Scavenging","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Scavenge multiple streams matching a pattern\n%%--------------------------------------------------------------------\n\n%% Scavenge all order streams older than 90 days\nNinetyDaysAgo = erlang:system_time(microsecond) - (90 * 24 * 60 * 60 * 1000000),\n\n{ok, Results} = esdb_gater_api:scavenge_matching(my_store, <<\"orders-*\">>, #{\n    before => NinetyDaysAgo,\n    require_snapshot => true\n}).\n\n%% Results is a list of per-stream results\n[\n    #{stream => <<\"orders-001\">>, deleted_count => 500},\n    #{stream => <<\"orders-002\">>, deleted_count => 823},\n    ...\n]\n```","ref":"scavenging.html#scavenge-matching-streams"},{"type":"extras","title":"Dry Run (Preview) - Scavenging","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Preview what would be deleted WITHOUT actually deleting\n%%--------------------------------------------------------------------\n\n%% ALWAYS preview before executing\n{ok, Preview} = esdb_gater_api:scavenge_dry_run(my_store, <<\"orders-123\">>, #{\n    before => ThirtyDaysAgo\n}).\n\n%% Preview shows impact without making changes\n#{\n    would_delete => 1523,\n    oldest_event => 1700000000000000,\n    newest_affected => 1702500000000000,\n    has_snapshot => true,\n    snapshot_version => 1500\n}\n```\n\n---","ref":"scavenging.html#dry-run-preview"},{"type":"extras","title":"Options Reference - Scavenging","doc":"| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `before` | integer | required | Delete events before this timestamp (microseconds) |\n| `require_snapshot` | boolean | `true` | Only scavenge if snapshot exists |\n| `keep_versions` | integer | 0 | Keep at least N most recent versions |\n| `archive_to` | atom | undefined | Archive backend before deletion |\n\n---","ref":"scavenging.html#options-reference"},{"type":"extras","title":"Use Cases - Scavenging","doc":"","ref":"scavenging.html#use-cases"},{"type":"extras","title":"1. Scheduled Storage Cleanup - Scavenging","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Daily automated scavenging job\n%%--------------------------------------------------------------------\n\n-module(scavenge_scheduler).\n\nrun_daily_scavenge() ->\n    RetentionDays = 90,\n    Cutoff = erlang:system_time(microsecond) -\n             (RetentionDays * 24 * 60 * 60 * 1000000),\n\n    %% Scavenge all order streams\n    {ok, Results} = esdb_gater_api:scavenge_matching(my_store, <<\"orders-*\">>, #{\n        before => Cutoff,\n        require_snapshot => true\n    }),\n\n    TotalDeleted = lists:foldl(\n        fun(#{deleted_count := N}, Acc) -> Acc + N end,\n        0,\n        Results\n    ),\n\n    logger:info(\"Scavenged ~p events from ~p streams\",\n                [TotalDeleted, length(Results)]).\n```","ref":"scavenging.html#1-scheduled-storage-cleanup"},{"type":"extras","title":"2. Compliance-Driven Archival - Scavenging","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Archive events before deleting for compliance\n%%--------------------------------------------------------------------\n\narchive_and_scavenge(StoreId, StreamId, RetentionDays) ->\n    Cutoff = erlang:system_time(microsecond) -\n             (RetentionDays * 24 * 60 * 60 * 1000000),\n\n    %% Archive to file before scavenging\n    {ok, _} = esdb_gater_api:scavenge(StoreId, StreamId, #{\n        before => Cutoff,\n        archive_to => file,\n        archive_path => <<\"/archive/\", StreamId/binary, \".events\">>\n    }).\n```\n\n---","ref":"scavenging.html#2-compliance-driven-archival"},{"type":"extras","title":"Safety Features - Scavenging","doc":"","ref":"scavenging.html#safety-features"},{"type":"extras","title":"Snapshot Requirement - Scavenging","doc":"By default, scavenging **requires** a snapshot to exist. This prevents accidental data loss:\n\n```erlang\n%% This will fail if no snapshot exists\n{error, no_snapshot} = esdb_gater_api:scavenge(my_store, StreamId, #{\n    before => Timestamp,\n    require_snapshot => true  %% Default\n}).\n\n%% Override only if you understand the consequences\n{ok, _} = esdb_gater_api:scavenge(my_store, StreamId, #{\n    before => Timestamp,\n    require_snapshot => false  %% DANGER: may lose state if no snapshot\n}).\n```","ref":"scavenging.html#snapshot-requirement"},{"type":"extras","title":"Keep Recent Versions - Scavenging","doc":"Always keep some recent events regardless of timestamp:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Keep a minimum event history for debugging\n%%--------------------------------------------------------------------\n\n{ok, _} = esdb_gater_api:scavenge(my_store, StreamId, #{\n    before => Timestamp,\n    keep_versions => 100  %% Always keep last 100 events\n}).\n```\n\n---","ref":"scavenging.html#keep-recent-versions"},{"type":"extras","title":"Common Pitfalls - Scavenging","doc":"","ref":"scavenging.html#common-pitfalls"},{"type":"extras","title":"1. Scavenging Without Snapshots - Scavenging","doc":"```erlang\n%% BAD: Scavenging without ensuring a snapshot exists\n{ok, _} = esdb_gater_api:scavenge(my_store, StreamId, #{\n    before => Timestamp,\n    require_snapshot => false  %% State might be lost!\n}).\n\n%% GOOD: Take a snapshot first, then scavenge\n{ok, State} = reconstruct_aggregate(StreamId),\n{ok, Version} = esdb_gater_api:save_snapshot(my_store, StreamId, State),\n{ok, _} = esdb_gater_api:scavenge(my_store, StreamId, #{\n    before => Timestamp,\n    require_snapshot => true\n}).\n```","ref":"scavenging.html#1-scavenging-without-snapshots"},{"type":"extras","title":"2. Wrong Timestamp Units - Scavenging","doc":"```erlang\n%% BAD: Using seconds instead of microseconds\nBadCutoff = erlang:system_time(second) - (30 * 24 * 60 * 60).\n\n%% GOOD: Using microseconds\nGoodCutoff = erlang:system_time(microsecond) - (30 * 24 * 60 * 60 * 1000000).\n```","ref":"scavenging.html#2-wrong-timestamp-units"},{"type":"extras","title":"3. Skipping Dry Run - Scavenging","doc":"```erlang\n%% BAD: Scavenging production data without preview\nesdb_gater_api:scavenge(prod_store, <<\"important-stream\">>, #{...}).\n\n%% GOOD: Always dry run first\n{ok, Preview} = esdb_gater_api:scavenge_dry_run(prod_store, <<\"important-stream\">>, #{...}),\nlogger:info(\"Would delete ~p events\", [maps:get(would_delete, Preview)]),\n%% Review preview, then proceed if acceptable\nesdb_gater_api:scavenge(prod_store, <<\"important-stream\">>, #{...}).\n```\n\n---","ref":"scavenging.html#3-skipping-dry-run"},{"type":"extras","title":"When to Scavenge - Scavenging","doc":"**Scavenge when:**\n\n- Storage costs are a concern\n- Events older than retention period have no business value\n- Snapshots exist for state reconstruction\n- Regulatory requirements permit deletion\n\n**Do NOT scavenge when:**\n\n- Full audit history is required (legal/compliance)\n- No snapshots exist (state would be lost)\n- Events have legal retention requirements\n- You haven't verified with a dry run first\n\n---","ref":"scavenging.html#when-to-scavenge"},{"type":"extras","title":"Best Practices - Scavenging","doc":"1. **Always dry run first** - Preview changes before executing\n2. **Ensure snapshots exist** - Take snapshots before scavenging\n3. **Use keep_versions** - Maintain some recent history for debugging\n4. **Archive if needed** - Preserve data for compliance before deletion\n5. **Schedule off-peak** - Scavenging is I/O intensive\n6. **Monitor space** - Track storage savings via telemetry\n\n---","ref":"scavenging.html#best-practices"},{"type":"extras","title":"Related Guides - Scavenging","doc":"- [Snapshots](snapshots.md) - Required for safe scavenging\n- [Temporal Queries](temporal_queries.md) - Query by timestamp before scavenging\n- [Event Sourcing](event_sourcing.md) - Core concepts","ref":"scavenging.html#related-guides"},{"type":"extras","title":"Causation Tracking","doc":"# Causation Tracking\n\nThis guide explains how to track the lineage of events through your system, enabling debugging, auditing, and visualization of event relationships.\n\n![Causation Graph](assets/causation_graph.svg)","ref":"causation.html"},{"type":"extras","title":"Prerequisites - Causation Tracking","doc":"Before reading this guide, you should understand:\n- Event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- How events propagate through process managers and sagas\n- The difference between commands (requests) and events (facts)","ref":"causation.html#prerequisites"},{"type":"extras","title":"The Problem: Understanding \"Why?\" - Causation Tracking","doc":"In event-driven systems, a single user action can trigger a cascade of events across multiple streams:\n\n```\nUser clicks \"Place Order\"\n     OrderPlaced event\n         PaymentRequested event\n             PaymentFailed event\n                 OrderCancelled event\n```\n\nWhen debugging, you need to answer:\n- \"What caused this PaymentFailed event?\"\n- \"What effects did the OrderPlaced event have?\"\n- \"Show me all events related to this order\"\n\nWithout causation tracking, you're searching through logs hoping to find connections.","ref":"causation.html#the-problem-understanding-why"},{"type":"extras","title":"The Solution: Causation and Correlation IDs - Causation Tracking","doc":"Every event carries metadata that links it to its origin:\n\n| Field | Purpose | Example |\n|-------|---------|---------|\n| `causation_id` | The ID of the event/command that **directly** caused this event | `\"evt-001\"` |\n| `correlation_id` | A shared ID grouping **all** events in a business process | `\"order-12345\"` |\n\n![Causation Chain](assets/causation_chain.svg)\n\n---","ref":"causation.html#the-solution-causation-and-correlation-ids"},{"type":"extras","title":"Where Does This Code Run? - Causation Tracking","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Set causation/correlation IDs | Your Application | Your command handlers |\n| Append events with metadata | Your Application | `esdb_gater_api` |\n| Query causation relationships | Your Application | `esdb_gater_api` |\n| Build causation graph | reckon-db Server | `reckon_db_causation` |\n| Generate DOT visualization | reckon-db Server | `esdb_graph_nif` |\n\n---","ref":"causation.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Causation Tracking","doc":"","ref":"causation.html#api-reference"},{"type":"extras","title":"Setting Causation Metadata - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (command handler)\n%% Purpose: Create events with proper causation chain\n%%--------------------------------------------------------------------\n\n-module(order_handler).\n\nhandle_command(Command, State) ->\n    CommandId = maps:get(id, Command),\n    %% Correlation ID groups all events in this business process\n    CorrelationId = maps:get(correlation_id, Command, CommandId),\n\n    Events = [\n        #{\n            event_type => <<\"OrderCreated\">>,\n            data => #{order_id => <<\"order-123\">>, items => [...]},\n            metadata => #{\n                causation_id => CommandId,       %% This command caused this event\n                correlation_id => CorrelationId  %% Part of this business process\n            }\n        }\n    ],\n\n    {ok, _} = esdb_gater_api:append_events(my_store, StreamId, Events).\n```","ref":"causation.html#setting-causation-metadata"},{"type":"extras","title":"Get Effects (What Did This Event Cause?) - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Find all events caused by a specific event\n%%--------------------------------------------------------------------\n\n%% What events did OrderCreated cause?\n{ok, Effects} = esdb_gater_api:get_effects(my_store, <<\"evt-001\">>).\n\n%% Returns events where causation_id = \"evt-001\"\n[\n    #{event_type => <<\"PaymentInitiated\">>, id => <<\"evt-002\">>, ...},\n    #{event_type => <<\"InventoryReserved\">>, id => <<\"evt-003\">>, ...}\n]\n```","ref":"causation.html#get-effects-what-did-this-event-cause"},{"type":"extras","title":"Get Cause (What Caused This Event?) - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Find the parent event in the causation chain\n%%--------------------------------------------------------------------\n\n%% What caused PaymentInitiated?\n{ok, Cause} = esdb_gater_api:get_cause(my_store, <<\"evt-002\">>).\n\n%% Returns the parent event\n#{event_type => <<\"OrderCreated\">>, id => <<\"evt-001\">>, ...}\n```","ref":"causation.html#get-cause-what-caused-this-event"},{"type":"extras","title":"Get Causation Chain (Root to Current) - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Trace the full causation path back to the root cause\n%%--------------------------------------------------------------------\n\n%% Trace PaymentFailed back to its origin\n{ok, Chain} = esdb_gater_api:get_causation_chain(my_store, <<\"evt-007\">>).\n\n%% Returns events from root to this event\n[\n    #{event_type => <<\"CreateOrderCommand\">>, id => <<\"cmd-001\">>, ...},  %% Root\n    #{event_type => <<\"OrderCreated\">>, id => <<\"evt-001\">>, ...},\n    #{event_type => <<\"PaymentInitiated\">>, id => <<\"evt-002\">>, ...},\n    #{event_type => <<\"PaymentFailed\">>, id => <<\"evt-007\">>, ...}        %% Current\n]\n```","ref":"causation.html#get-causation-chain-root-to-current"},{"type":"extras","title":"Get Correlated Events (Entire Business Process) - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Find all events sharing the same correlation ID\n%%--------------------------------------------------------------------\n\n%% Get all events for order processing\n{ok, Events} = esdb_gater_api:get_correlated(my_store, <<\"order-12345\">>).\n\n%% Returns all events with correlation_id = \"order-12345\"\n```","ref":"causation.html#get-correlated-events-entire-business-process"},{"type":"extras","title":"Build Causation Graph (For Visualization) - Causation Tracking","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Build a graph structure for visualization tools\n%%--------------------------------------------------------------------\n\n{ok, Graph} = esdb_gater_api:build_causation_graph(my_store, <<\"evt-001\">>).\n\n%% Returns a graph structure\n#{\n    nodes => [\n        #{id => <<\"evt-001\">>, type => <<\"OrderCreated\">>, ...},\n        #{id => <<\"evt-002\">>, type => <<\"PaymentInitiated\">>, ...},\n        ...\n    ],\n    edges => [\n        #{from => <<\"evt-001\">>, to => <<\"evt-002\">>},\n        #{from => <<\"evt-001\">>, to => <<\"evt-003\">>},\n        ...\n    ],\n    roots => [<<\"evt-001\">>],\n    leaves => [<<\"evt-005\">>, <<\"evt-006\">>, <<\"evt-007\">>]\n}\n```\n\n---","ref":"causation.html#build-causation-graph-for-visualization"},{"type":"extras","title":"Use Cases - Causation Tracking","doc":"","ref":"causation.html#use-cases"},{"type":"extras","title":"1. Debugging Failed Processes - Causation Tracking","doc":"When a payment fails, trace back to understand the full context:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Debug a failure by tracing its causation chain\n%%--------------------------------------------------------------------\n\n-module(incident_investigator).\n\ndebug_failure(StoreId, FailedEventId) ->\n    %% Get the causation chain (how we got here)\n    {ok, Chain} = esdb_gater_api:get_causation_chain(StoreId, FailedEventId),\n\n    %% Get all related events (what else happened)\n    {ok, FailedEvent} = get_event(StoreId, FailedEventId),\n    CorrelationId = maps:get(correlation_id, maps:get(metadata, FailedEvent)),\n    {ok, AllEvents} = esdb_gater_api:get_correlated(StoreId, CorrelationId),\n\n    #{\n        causation_chain => Chain,          %% Direct ancestors\n        all_related_events => AllEvents,   %% Everything in this process\n        root_cause => hd(Chain)            %% Where it all started\n    }.\n```","ref":"causation.html#1-debugging-failed-processes"},{"type":"extras","title":"2. Process Manager/Saga Tracking - Causation Tracking","doc":"Track saga execution across multiple aggregates:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (process manager)\n%% Purpose: Create events with saga correlation\n%%--------------------------------------------------------------------\n\n-module(order_saga).\n\nstart_saga(OrderId) ->\n    %% Order ID becomes the correlation ID for the entire saga\n    CorrelationId = OrderId,\n    SagaStartCommand = #{\n        id => generate_id(),\n        correlation_id => CorrelationId,\n        order_id => OrderId\n    },\n    handle_command(SagaStartCommand).\n\n%% Later: check saga progress\nget_saga_status(OrderId) ->\n    {ok, Events} = esdb_gater_api:get_correlated(my_store, OrderId),\n    analyze_saga_state(Events).\n```","ref":"causation.html#2-process-manager-saga-tracking"},{"type":"extras","title":"3. Visualization with Graphviz - Causation Tracking","doc":"Export causation graphs for visual analysis:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Generate a visual diagram of event relationships\n%%--------------------------------------------------------------------\n\nvisualize_causation(StoreId, EventId) ->\n    {ok, Graph} = esdb_gater_api:build_causation_graph(StoreId, EventId),\n\n    %% Convert to DOT format (using esdb_graph_nif on server)\n    DOT = esdb_graph_nif:to_dot(Graph),\n\n    %% Write to file and render with Graphviz\n    file:write_file(\"causation.dot\", DOT),\n    os:cmd(\"dot -Tpng causation.dot -o causation.png\").\n```\n\n---","ref":"causation.html#3-visualization-with-graphviz"},{"type":"extras","title":"Event Metadata Schema - Causation Tracking","doc":"Recommended metadata structure for all events:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Standard metadata structure for causation tracking\n%%--------------------------------------------------------------------\n\ncreate_event_metadata(CausingId, CorrelationId, ActorId) ->\n    #{\n        %% Causation tracking (required for lineage)\n        causation_id => CausingId,         %% ID of the causing event/command\n        correlation_id => CorrelationId,   %% Business process ID\n\n        %% Additional context (optional but recommended)\n        actor_id => ActorId,               %% Who/what triggered this\n        timestamp => erlang:system_time(microsecond),  %% When it happened\n        source => atom_to_binary(node())   %% Which node/service\n    }.\n```\n\n---","ref":"causation.html#event-metadata-schema"},{"type":"extras","title":"Common Pitfalls - Causation Tracking","doc":"","ref":"causation.html#common-pitfalls"},{"type":"extras","title":"1. Missing Causation in Event Handlers - Causation Tracking","doc":"```erlang\n%% BAD: Event handler creates new events without causation link\nhandle_event(OrderCreated, State) ->\n    NewEvent = #{event_type => <<\"PaymentRequested\">>, data => ...},\n    %% Missing causation_id! Lineage is broken.\n    esdb_gater_api:append_events(Store, Stream, [NewEvent]).\n\n%% GOOD: Preserve causation chain\nhandle_event(OrderCreated = #{id := EventId, metadata := Meta}, State) ->\n    CorrelationId = maps:get(correlation_id, Meta),\n    NewEvent = #{\n        event_type => <<\"PaymentRequested\">>,\n        data => ...,\n        metadata => #{\n            causation_id => EventId,        %% This event caused the new one\n            correlation_id => CorrelationId  %% Same business process\n        }\n    },\n    esdb_gater_api:append_events(Store, Stream, [NewEvent]).\n```","ref":"causation.html#1-missing-causation-in-event-handlers"},{"type":"extras","title":"2. Using Wrong ID for Correlation - Causation Tracking","doc":"```erlang\n%% BAD: Using event ID as correlation (changes with each event)\nmetadata => #{\n    causation_id => EventId,\n    correlation_id => EventId  %% Wrong! Each event has different correlation\n}\n\n%% GOOD: Use stable business ID as correlation\nmetadata => #{\n    causation_id => EventId,\n    correlation_id => OrderId  %% Same for all events in this order\n}\n```","ref":"causation.html#2-using-wrong-id-for-correlation"},{"type":"extras","title":"3. Not Generating Unique IDs - Causation Tracking","doc":"```erlang\n%% BAD: Predictable IDs can collide\nEventId = <<\"event-1\">>,\n\n%% GOOD: Use UUIDs or similar\nEventId = uuid:uuid_to_string(uuid:get_v4()),\n```\n\n---","ref":"causation.html#3-not-generating-unique-ids"},{"type":"extras","title":"When NOT to Use Causation Queries - Causation Tracking","doc":"- **Simple aggregate reads** - Just read the stream by version\n- **High-frequency queries** - Causation queries traverse indexes; use sparingly\n- **Real-time monitoring** - Use subscriptions instead\n\nCausation queries are designed for **debugging, auditing, and analysis**, not hot-path operations.\n\n---","ref":"causation.html#when-not-to-use-causation-queries"},{"type":"extras","title":"Best Practices - Causation Tracking","doc":"1. **Always set causation_id** - Every event should reference its cause\n2. **Use correlation_id for business processes** - Group related events across streams\n3. **Generate unique IDs** - Use UUIDs to avoid collisions\n4. **Include in command metadata** - Pass correlation through commands to events\n5. **Log causation in errors** - Include the chain in error reports for debugging\n\n---","ref":"causation.html#best-practices"},{"type":"extras","title":"Related Guides - Causation Tracking","doc":"- [Event Sourcing](event_sourcing.md) - Core concepts\n- [Subscriptions](subscriptions.md) - React to events in real-time\n- [CQRS](cqrs.md) - Command/Query separation patterns","ref":"causation.html#related-guides"},{"type":"extras","title":"Schema Evolution","doc":"# Schema Evolution\n\nThis guide explains how to evolve event schemas over time while maintaining backward compatibility. Old events are automatically \"upcasted\" to the current schema version when read.\n\n![Schema Upcasting](assets/schema_upcasting.svg)","ref":"schema_evolution.html"},{"type":"extras","title":"Prerequisites - Schema Evolution","doc":"Before reading this guide, you should understand:\n- Event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- The immutable nature of events (events are never modified after being written)\n- Why backward compatibility matters in event-driven systems","ref":"schema_evolution.html#prerequisites"},{"type":"extras","title":"The Problem: Business Requirements Change - Schema Evolution","doc":"In event sourcing, events are immutable facts. But business requirements evolve:\n\n- New fields are added (`phone` added to `UserCreated`)\n- Field names are renamed (`amount_cents`  `amount`)\n- Data formats change (cents as integer  dollars as decimal)\n- Fields are split (`full_name`  `first_name` + `last_name`)\n\n**You cannot migrate events** - they're immutable historical records. Changing them would break the audit trail.","ref":"schema_evolution.html#the-problem-business-requirements-change"},{"type":"extras","title":"The Solution: Schema Registry + Upcasting - Schema Evolution","doc":"Instead of migrating events, we transform them **on read**:\n\n```\nWrite (immutable):           Read (transformed):\n         \n UserCreated v1             UserCreated v3   \n {                   {                \n   name: \"Alice\",  upcast     name: \"Alice\", \n   email: \"...\"               email: \"...\",  \n }                            phone: null,   \n            verified: false\n                              }                \n                             \n```\n\n**Key insight:** Events stay as written. Transformation happens at read time. Consumers always see the current schema.\n\n---","ref":"schema_evolution.html#the-solution-schema-registry-upcasting"},{"type":"extras","title":"Where Does This Code Run? - Schema Evolution","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Register schema | Your Application | `esdb_gater_api` |\n| Define upcast functions | Your Application | Your schema module |\n| Store schema definitions | reckon-db Server | `reckon_db_schema_store` |\n| Apply upcasting on read | reckon-db Server | `reckon_db_upcaster` |\n\n---","ref":"schema_evolution.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Schema Evolution","doc":"","ref":"schema_evolution.html#api-reference"},{"type":"extras","title":"Register a Schema - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Register initial schema version for an event type\n%%--------------------------------------------------------------------\n\nesdb_gater_api:register_schema(my_store, <<\"UserCreated\">>, #{\n    version => 1,\n    fields => [\n        #{name => <<\"name\">>, type => string, required => true},\n        #{name => <<\"email\">>, type => string, required => true}\n    ]\n}).\n```","ref":"schema_evolution.html#register-a-schema"},{"type":"extras","title":"Register New Version with Upcast - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Add new schema version with transformation from v1\n%%--------------------------------------------------------------------\n\nesdb_gater_api:register_schema(my_store, <<\"UserCreated\">>, #{\n    version => 2,\n    fields => [\n        #{name => <<\"name\">>, type => string, required => true},\n        #{name => <<\"email\">>, type => string, required => true},\n        #{name => <<\"phone\">>, type => string, required => false}  %% New field\n    ],\n    upcast_from => #{\n        1 => fun(V1Data) ->\n            %% Transform v1  v2: add missing phone field\n            V1Data#{<<\"phone\">> => undefined}\n        end\n    }\n}).\n```","ref":"schema_evolution.html#register-new-version-with-upcast"},{"type":"extras","title":"Get Schema Information - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Query registered schemas\n%%--------------------------------------------------------------------\n\n%% Get current schema for an event type\n{ok, Schema} = esdb_gater_api:get_schema(my_store, <<\"UserCreated\">>).\n\n%% Get current version number\n{ok, Version} = esdb_gater_api:get_schema_version(my_store, <<\"UserCreated\">>).\n%% => {ok, 2}\n\n%% List all registered schemas\n{ok, Schemas} = esdb_gater_api:list_schemas(my_store).\n%% => [\n%%     #{event_type => <<\"UserCreated\">>, version => 2},\n%%     #{event_type => <<\"OrderPlaced\">>, version => 3},\n%%     ...\n%% ]\n```","ref":"schema_evolution.html#get-schema-information"},{"type":"extras","title":"Upcast Events Explicitly - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Manually upcast events to current schema version\n%%--------------------------------------------------------------------\n\n%% Read old events\n{ok, OldEvents} = esdb_gater_api:stream_forward(my_store, StreamId, 0, 100),\n\n%% Upcast to current schema versions\n{ok, UpcastedEvents} = esdb_gater_api:upcast_events(my_store, OldEvents).\n\n%% Events are now in current schema version\n```","ref":"schema_evolution.html#upcast-events-explicitly"},{"type":"extras","title":"Unregister Schema - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Remove a deprecated event type's schema\n%%--------------------------------------------------------------------\n\nesdb_gater_api:unregister_schema(my_store, <<\"DeprecatedEvent\">>).\n```\n\n---","ref":"schema_evolution.html#unregister-schema"},{"type":"extras","title":"Upcast Chain - Schema Evolution","doc":"When multiple schema versions exist, upcasting chains automatically:\n\n```\nv1 event  upcast_v1_v2()  v2 data  upcast_v2_v3()  v3 data (current)\n```\n\nExample with 3 versions:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Register schema with full upcast chain\n%%--------------------------------------------------------------------\n\nesdb_gater_api:register_schema(my_store, <<\"OrderPlaced\">>, #{\n    version => 3,\n    fields => [\n        #{name => <<\"order_id\">>, type => string},\n        #{name => <<\"amount\">>, type => decimal},       %% Changed from cents in v1\n        #{name => <<\"currency\">>, type => string},      %% Added in v2\n        #{name => <<\"customer_id\">>, type => string}    %% Added in v3\n    ],\n    upcast_from => #{\n        1 => fun(V1) ->\n            %% v1 had amount_cents (integer), no currency\n            #{\n                <<\"order_id\">> => maps:get(<<\"order_id\">>, V1),\n                <<\"amount\">> => maps:get(<<\"amount_cents\">>, V1) / 100,\n                <<\"currency\">> => <<\"USD\">>,  %% Default for old events\n                <<\"customer_id\">> => undefined\n            }\n        end,\n        2 => fun(V2) ->\n            %% v2 had amount + currency, no customer\n            V2#{<<\"customer_id\">> => undefined}\n        end\n    }\n}).\n```\n\n---","ref":"schema_evolution.html#upcast-chain"},{"type":"extras","title":"Common Transformation Patterns - Schema Evolution","doc":"","ref":"schema_evolution.html#common-transformation-patterns"},{"type":"extras","title":"Adding Fields (Most Common) - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Add new field with default value\n%%--------------------------------------------------------------------\n\nupcast_from => #{\n    1 => fun(V1) ->\n        V1#{<<\"new_field\">> => default_value}\n    end\n}\n```","ref":"schema_evolution.html#adding-fields-most-common"},{"type":"extras","title":"Renaming Fields - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Rename a field while preserving data\n%%--------------------------------------------------------------------\n\nupcast_from => #{\n    1 => fun(V1) ->\n        OldValue = maps:get(<<\"old_name\">>, V1),\n        maps:remove(<<\"old_name\">>, V1#{<<\"new_name\">> => OldValue})\n    end\n}\n```","ref":"schema_evolution.html#renaming-fields"},{"type":"extras","title":"Changing Data Types - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Convert data format (cents  dollars)\n%%--------------------------------------------------------------------\n\nupcast_from => #{\n    1 => fun(V1) ->\n        %% Convert cents (integer) to dollars (decimal)\n        Cents = maps:get(<<\"amount_cents\">>, V1),\n        maps:remove(<<\"amount_cents\">>, V1#{<<\"amount\">> => Cents / 100})\n    end\n}\n```","ref":"schema_evolution.html#changing-data-types"},{"type":"extras","title":"Splitting Fields - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Split one field into multiple fields\n%%--------------------------------------------------------------------\n\nupcast_from => #{\n    1 => fun(V1) ->\n        %% Split \"full_name\" into \"first_name\" and \"last_name\"\n        FullName = maps:get(<<\"full_name\">>, V1),\n        [First | Rest] = binary:split(FullName, <<\" \">>),\n        Last = iolist_to_binary(lists:join(<<\" \">>, Rest)),\n        maps:remove(<<\"full_name\">>, V1#{\n            <<\"first_name\">> => First,\n            <<\"last_name\">> => Last\n        })\n    end\n}\n```","ref":"schema_evolution.html#splitting-fields"},{"type":"extras","title":"Merging Fields - Schema Evolution","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Combine multiple fields into one\n%%--------------------------------------------------------------------\n\nupcast_from => #{\n    1 => fun(V1) ->\n        Street = maps:get(<<\"street\">>, V1),\n        City = maps:get(<<\"city\">>, V1),\n        Combined = < >,\n        maps:without([<<\"street\">>, <<\"city\">>], V1#{<<\"address\">> => Combined})\n    end\n}\n```\n\n---","ref":"schema_evolution.html#merging-fields"},{"type":"extras","title":"Common Pitfalls - Schema Evolution","doc":"","ref":"schema_evolution.html#common-pitfalls"},{"type":"extras","title":"1. Modifying Existing Schema Version - Schema Evolution","doc":"```erlang\n%% BAD: Changing v1 schema after events are written\nesdb_gater_api:register_schema(Store, <<\"Event\">>, #{\n    version => 1,\n    fields => [...different fields...]  %% Breaks existing v1 events!\n}).\n\n%% GOOD: Create new version instead\nesdb_gater_api:register_schema(Store, <<\"Event\">>, #{\n    version => 2,\n    fields => [...new fields...],\n    upcast_from => #{1 => fun(V1) -> ... end}\n}).\n```","ref":"schema_evolution.html#1-modifying-existing-schema-version"},{"type":"extras","title":"2. Upcast Functions with Side Effects - Schema Evolution","doc":"```erlang\n%% BAD: Side effects in upcast function\nupcast_from => #{\n    1 => fun(V1) ->\n        log(\"Upcasting event!\"),  %% Side effect!\n        http:post(webhook, V1),   %% Network call!\n        V1#{<<\"new_field\">> => fetch_from_db()}  %% Database read!\n    end\n}\n\n%% GOOD: Pure transformation only\nupcast_from => #{\n    1 => fun(V1) ->\n        V1#{<<\"new_field\">> => <<\"default\">>}  %% Deterministic\n    end\n}\n```","ref":"schema_evolution.html#2-upcast-functions-with-side-effects"},{"type":"extras","title":"3. Lossy Transformations Without Documentation - Schema Evolution","doc":"```erlang\n%% BAD: Silent data loss\nupcast_from => #{\n    1 => fun(V1) ->\n        %% Precision loss: cents truncated\n        Cents = maps:get(<<\"amount_cents\">>, V1),\n        V1#{<<\"amount_dollars\">> => Cents div 100}  %% 199 cents  1 dollar\n    end\n}\n\n%% GOOD: Document and minimize loss\n%% @doc Converts cents to dollars. Note: sub-dollar precision is preserved.\nupcast_from => #{\n    1 => fun(V1) ->\n        Cents = maps:get(<<\"amount_cents\">>, V1),\n        V1#{<<\"amount\">> => Cents / 100.0}  %% 199 cents  1.99\n    end\n}\n```","ref":"schema_evolution.html#3-lossy-transformations-without-documentation"},{"type":"extras","title":"4. Missing Schema Version in Event - Schema Evolution","doc":"```erlang\n%% BAD: No way to know which version this event uses\nEvent = #{\n    event_type => <<\"UserCreated\">>,\n    data => #{name => <<\"Alice\">>}\n}.\n\n%% GOOD: Include schema version in metadata\nEvent = #{\n    event_type => <<\"UserCreated\">>,\n    data => #{name => <<\"Alice\">>},\n    metadata => #{schema_version => 2}\n}.\n```\n\n---","ref":"schema_evolution.html#4-missing-schema-version-in-event"},{"type":"extras","title":"Best Practices - Schema Evolution","doc":"1. **Always increment versions** - Never modify existing schema versions\n2. **Keep upcast functions pure** - No side effects, deterministic results\n3. **Test upcast chains** - Verify v1v3 produces correct results\n4. **Document breaking changes** - Note when upcasting loses information\n5. **Store version in event metadata** - Makes debugging easier\n6. **Register schemas at application startup** - Ensure schemas are available before reads\n\n---","ref":"schema_evolution.html#best-practices"},{"type":"extras","title":"Event Metadata with Schema Version - Schema Evolution","doc":"Include version in event metadata for traceability:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Include schema version when creating events\n%%--------------------------------------------------------------------\n\ncreate_event(Type, Data, Metadata) ->\n    {ok, Version} = esdb_gater_api:get_schema_version(my_store, Type),\n    #{\n        event_type => Type,\n        data => Data,\n        metadata => Metadata#{schema_version => Version}\n    }.\n```\n\n---","ref":"schema_evolution.html#event-metadata-with-schema-version"},{"type":"extras","title":"When NOT to Use Schema Evolution - Schema Evolution","doc":"- **Breaking changes requiring re-processing** - If you need to change the meaning of old events, consider creating a new event type instead\n- **Simple field additions** - If all consumers can handle missing fields, you might not need formal schemas\n- **Performance-critical hot paths** - Upcasting adds processing overhead\n\n---","ref":"schema_evolution.html#when-not-to-use-schema-evolution"},{"type":"extras","title":"Related Guides - Schema Evolution","doc":"- [Event Sourcing](event_sourcing.md) - Core concepts\n- [Subscriptions](subscriptions.md) - Events are upcasted on delivery\n- [Snapshots](snapshots.md) - Snapshots use current schema","ref":"schema_evolution.html#related-guides"},{"type":"extras","title":"Stream Links","doc":"# Stream Links\n\nThis guide explains how to create derived streams from source streams using filters and transformations, enabling specialized views without duplicating event storage.\n\n![Stream Links](assets/stream_links.svg)","ref":"stream_links.html"},{"type":"extras","title":"Prerequisites - Stream Links","doc":"Before reading this guide, you should understand:\n- Event sourcing concepts ([Event Sourcing Guide](event_sourcing.md))\n- Stream subscriptions ([Subscriptions Guide](subscriptions.md))\n- CQRS and read model patterns ([CQRS Guide](cqrs.md))","ref":"stream_links.html#prerequisites"},{"type":"extras","title":"The Problem: Filtering Events Across Streams - Stream Links","doc":"In a real application, you often need to work with subsets of events:\n\n- \"Show me all high-value orders across all order streams\"\n- \"Give me all payment events regardless of which stream they're in\"\n- \"I only care about events from US customers\"\n\nWithout stream links, you'd need to:\n1. Subscribe to all source streams\n2. Filter events in your application code\n3. Build and maintain your own derived storage\n\nThis is complex, error-prone, and duplicates effort across applications.","ref":"stream_links.html#the-problem-filtering-events-across-streams"},{"type":"extras","title":"The Solution: Stream Links - Stream Links","doc":"Stream links create **derived streams** that:\n\n1. Subscribe to source streams (with pattern matching)\n2. Filter events based on criteria\n3. Optionally transform/enrich events\n4. Make results available as a regular stream\n\n```\nSource Streams:              Link:                    Derived Stream:\n\n orders-001             \n amount: 500                                     $link:high-value \n      filter:                             \n orders-002                  amount > 1000       orders-002       \n amount: 2500                               orders-003       \n         transform:                             \n orders-003             add priority       \n amount: 1500                                 \n         \n```\n\n---","ref":"stream_links.html#the-solution-stream-links"},{"type":"extras","title":"Where Does This Code Run? - Stream Links","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Create/configure links | Your Application | `esdb_gater_api` |\n| Store link definitions | reckon-db Server | `reckon_db_links` |\n| Filter/transform processing | reckon-db Server | `reckon_db_link_worker` |\n| Subscribe to derived stream | Your Application | `esdb_gater_api` |\n\n---","ref":"stream_links.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Stream Links","doc":"","ref":"stream_links.html#api-reference"},{"type":"extras","title":"Create a Link - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Create a derived stream for high-value orders\n%%--------------------------------------------------------------------\n\nesdb_gater_api:create_link(my_store, #{\n    name => <<\"high-value-orders\">>,\n    source => #{\n        type => stream_pattern,\n        pattern => <<\"orders-*\">>     %% Watch all order streams\n    },\n    filter => #{\n        field => <<\"amount\">>,\n        op => '>',\n        value => 1000\n    },\n    transform => #{\n        add_fields => #{\n            <<\"priority\">> => <<\"high\">>,\n            <<\"flagged_at\">> => {fn, fun() -> erlang:system_time(microsecond) end}\n        }\n    }\n}).\n```","ref":"stream_links.html#create-a-link"},{"type":"extras","title":"Get Link Info - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Check link configuration and status\n%%--------------------------------------------------------------------\n\n{ok, Link} = esdb_gater_api:get_link(my_store, <<\"high-value-orders\">>).\n%% => #{\n%%     name => <<\"high-value-orders\">>,\n%%     source => #{type => stream_pattern, pattern => <<\"orders-*\">>},\n%%     filter => #{...},\n%%     status => running,\n%%     events_processed => 12345\n%% }\n```","ref":"stream_links.html#get-link-info"},{"type":"extras","title":"List All Links - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Get all configured links for a store\n%%--------------------------------------------------------------------\n\n{ok, Links} = esdb_gater_api:list_links(my_store).\n```","ref":"stream_links.html#list-all-links"},{"type":"extras","title":"Start/Stop a Link - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Pause and resume link processing\n%%--------------------------------------------------------------------\n\n%% Stop processing (link remains configured, will resume from last position)\nesdb_gater_api:stop_link(my_store, <<\"high-value-orders\">>).\n\n%% Resume processing\nesdb_gater_api:start_link(my_store, <<\"high-value-orders\">>).\n```","ref":"stream_links.html#start-stop-a-link"},{"type":"extras","title":"Delete a Link - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Remove a link and its derived stream\n%%--------------------------------------------------------------------\n\nesdb_gater_api:delete_link(my_store, <<\"high-value-orders\">>).\n```","ref":"stream_links.html#delete-a-link"},{"type":"extras","title":"Detailed Link Statistics - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Get detailed processing statistics\n%%--------------------------------------------------------------------\n\n{ok, Info} = esdb_gater_api:link_info(my_store, <<\"high-value-orders\">>).\n%% => #{\n%%     status => running,\n%%     events_processed => 12345,      %% Events that matched filter\n%%     events_filtered => 45678,       %% Events that didn't match\n%%     last_processed_at => 1703001600000000,\n%%     lag => 0,                       %% Events behind real-time\n%%     source_streams => [<<\"orders-001\">>, <<\"orders-002\">>, ...]\n%% }\n```\n\n---","ref":"stream_links.html#detailed-link-statistics"},{"type":"extras","title":"Subscribing to Links - Stream Links","doc":"Links create streams prefixed with `$link:`:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Subscribe to derived stream events\n%%--------------------------------------------------------------------\n\n%% Subscribe to the derived stream via gateway (just like any other stream)\nok = esdb_gater_api:save_subscription(\n    my_store,\n    stream,\n    <<\"$link:high-value-orders\">>,\n    <<\"my-handler\">>,\n    self(),\n    #{}\n).\n\n%% Read from the derived stream\n{ok, Events} = esdb_gater_api:stream_forward(\n    my_store,\n    <<\"$link:high-value-orders\">>,\n    0,\n    100\n).\n```\n\n---","ref":"stream_links.html#subscribing-to-links"},{"type":"extras","title":"Filter Operators - Stream Links","doc":"| Operator | Description | Example |\n|----------|-------------|---------|\n| `=` | Equals | `#{field => <<\"status\">>, op => '=', value => <<\"active\">>}` |\n| `!=` | Not equals | `#{field => <<\"type\">>, op => '!=', value => <<\"test\">>}` |\n| `>` | Greater than | `#{field => <<\"amount\">>, op => '>', value => 100}` |\n| `>=` | Greater or equal | `#{field => <<\"count\">>, op => '>=', value => 5}` |\n| `<` | Less than | `#{field => <<\"age\">>, op => '<', value => 30}` |\n| `<=` | Less or equal | `#{field => <<\"priority\">>, op => '<=', value => 3}` |\n| `in` | In list | `#{field => <<\"country\">>, op => in, value => [<<\"US\">>, <<\"UK\">>]}` |\n| `contains` | String contains | `#{field => <<\"email\">>, op => contains, value => <<\"@company.com\">>}` |\n| `matches` | Regex match | `#{field => <<\"sku\">>, op => matches, value => <<\"^SKU-\\\\d+\">>}` |","ref":"stream_links.html#filter-operators"},{"type":"extras","title":"Compound Filters - Stream Links","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Combine multiple filter conditions\n%%--------------------------------------------------------------------\n\n%% AND filter (all conditions must match)\nfilter => #{\n    type => 'and',\n    filters => [\n        #{field => <<\"amount\">>, op => '>', value => 1000},\n        #{field => <<\"status\">>, op => '=', value => <<\"completed\">>}\n    ]\n}\n\n%% OR filter (any condition matches)\nfilter => #{\n    type => 'or',\n    filters => [\n        #{field => <<\"priority\">>, op => '=', value => <<\"high\">>},\n        #{field => <<\"amount\">>, op => '>', value => 5000}\n    ]\n}\n```\n\n---","ref":"stream_links.html#compound-filters"},{"type":"extras","title":"Transform Options - Stream Links","doc":"","ref":"stream_links.html#transform-options"},{"type":"extras","title":"Add Static Fields - Stream Links","doc":"```erlang\ntransform => #{\n    add_fields => #{\n        <<\"processed_by\">> => <<\"link-worker\">>,\n        <<\"link_version\">> => 1\n    }\n}\n```","ref":"stream_links.html#add-static-fields"},{"type":"extras","title":"Add Dynamic Fields - Stream Links","doc":"```erlang\ntransform => #{\n    add_fields => #{\n        <<\"processed_at\">> => {fn, fun() -> erlang:system_time(microsecond) end},\n        <<\"random_id\">> => {fn, fun() -> crypto:strong_rand_bytes(16) end}\n    }\n}\n```","ref":"stream_links.html#add-dynamic-fields"},{"type":"extras","title":"Remove Fields (Sanitize) - Stream Links","doc":"```erlang\ntransform => #{\n    remove_fields => [<<\"internal_id\">>, <<\"debug_info\">>, <<\"password_hash\">>]\n}\n```","ref":"stream_links.html#remove-fields-sanitize"},{"type":"extras","title":"Rename Fields - Stream Links","doc":"```erlang\ntransform => #{\n    rename_fields => #{\n        <<\"old_name\">> => <<\"new_name\">>,\n        <<\"legacy_field\">> => <<\"modern_field\">>\n    }\n}\n```\n\n---","ref":"stream_links.html#rename-fields"},{"type":"extras","title":"Use Cases - Stream Links","doc":"","ref":"stream_links.html#use-cases"},{"type":"extras","title":"1. Category-Based Views - Stream Links","doc":"Create per-category views from a mixed stream:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Separate streams by product category\n%%--------------------------------------------------------------------\n\n%% Electronics orders\nesdb_gater_api:create_link(my_store, #{\n    name => <<\"electronics-orders\">>,\n    source => #{type => stream_pattern, pattern => <<\"orders-*\">>},\n    filter => #{field => <<\"category\">>, op => '=', value => <<\"electronics\">>}\n}).\n\n%% Clothing orders\nesdb_gater_api:create_link(my_store, #{\n    name => <<\"clothing-orders\">>,\n    source => #{type => stream_pattern, pattern => <<\"orders-*\">>},\n    filter => #{field => <<\"category\">>, op => '=', value => <<\"clothing\">>}\n}).\n```","ref":"stream_links.html#1-category-based-views"},{"type":"extras","title":"2. Event Type Aggregation - Stream Links","doc":"Group events by type across all streams:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: All payment events in one stream\n%%--------------------------------------------------------------------\n\nesdb_gater_api:create_link(my_store, #{\n    name => <<\"all-payments\">>,\n    source => #{type => stream_pattern, pattern => <<\"*\">>},\n    filter => #{field => <<\"event_type\">>, op => in, value => [\n        <<\"PaymentReceived\">>,\n        <<\"PaymentFailed\">>,\n        <<\"RefundIssued\">>\n    ]}\n}).\n```","ref":"stream_links.html#2-event-type-aggregation"},{"type":"extras","title":"3. Compliance Flagging - Stream Links","doc":"Automatically flag events for review:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Flag high-value transactions for compliance review\n%%--------------------------------------------------------------------\n\nesdb_gater_api:create_link(my_store, #{\n    name => <<\"flagged-transactions\">>,\n    source => #{type => stream_pattern, pattern => <<\"transactions-*\">>},\n    filter => #{field => <<\"amount\">>, op => '>', value => 10000},\n    transform => #{\n        add_fields => #{\n            <<\"requires_review\">> => true,\n            <<\"flagged_at\">> => {fn, fun() -> erlang:system_time(microsecond) end},\n            <<\"review_queue\">> => <<\"compliance\">>\n        }\n    }\n}).\n```\n\n---","ref":"stream_links.html#3-compliance-flagging"},{"type":"extras","title":"Common Pitfalls - Stream Links","doc":"","ref":"stream_links.html#common-pitfalls"},{"type":"extras","title":"1. Overly Broad Patterns - Stream Links","doc":"```erlang\n%% BAD: Watching everything can be expensive\nsource => #{type => stream_pattern, pattern => <<\"*\">>}\n\n%% GOOD: Be specific about what you need\nsource => #{type => stream_pattern, pattern => <<\"orders-*\">>}\n```","ref":"stream_links.html#1-overly-broad-patterns"},{"type":"extras","title":"2. Complex Filters on Hot Paths - Stream Links","doc":"```erlang\n%% BAD: Regex on every event is expensive\nfilter => #{field => <<\"data\">>, op => matches, value => complex_regex}\n\n%% GOOD: Use simple equality checks when possible\nfilter => #{field => <<\"type\">>, op => '=', value => <<\"payment\">>}\n```","ref":"stream_links.html#2-complex-filters-on-hot-paths"},{"type":"extras","title":"3. Not Monitoring Lag - Stream Links","doc":"```erlang\n%% BAD: Ignoring link health\nesdb_gater_api:create_link(my_store, #{...}).\n%% ... never check if it's keeping up\n\n%% GOOD: Monitor lag for real-time requirements\ncheck_link_health(LinkName) ->\n    {ok, Info} = esdb_gater_api:link_info(my_store, LinkName),\n    Lag = maps:get(lag, Info),\n    if Lag > 1000 ->\n        logger:warning(\"Link ~p is ~p events behind\", [LinkName, Lag]);\n       true -> ok\n    end.\n```","ref":"stream_links.html#3-not-monitoring-lag"},{"type":"extras","title":"4. Transforming Critical Data - Stream Links","doc":"```erlang\n%% BAD: Removing fields you might need later\ntransform => #{remove_fields => [<<\"metadata\">>]}\n\n%% GOOD: Be conservative about data removal\ntransform => #{\n    remove_fields => [<<\"internal_debug\">>, <<\"temp_marker\">>]\n    %% Keep metadata, causation_id, correlation_id, etc.\n}\n```\n\n---","ref":"stream_links.html#4-transforming-critical-data"},{"type":"extras","title":"When NOT to Use Stream Links - Stream Links","doc":"- **Simple subscriptions** - If you just need to react to events, use regular subscriptions\n- **One-time queries** - For ad-hoc analysis, use temporal queries instead\n- **Complex transformations** - If transformation logic is complex, build a proper projection\n- **Cross-store aggregation** - Links work within a single store\n\n---","ref":"stream_links.html#when-not-to-use-stream-links"},{"type":"extras","title":"Performance Considerations - Stream Links","doc":"- Links process events asynchronously (won't block writers)\n- Backpressure-aware (won't overwhelm consumers)\n- Can be paused/resumed for maintenance\n- Monitor `lag` metric for real-time requirements\n- Use specific patterns over wildcards when possible\n\n---","ref":"stream_links.html#performance-considerations"},{"type":"extras","title":"Related Guides - Stream Links","doc":"- [Subscriptions](subscriptions.md) - Subscribe to derived streams\n- [Event Sourcing](event_sourcing.md) - Core concepts\n- [CQRS](cqrs.md) - Links as lightweight projections","ref":"stream_links.html#related-guides"},{"type":"extras","title":"Memory Pressure","doc":"# Memory Pressure\n\nThis guide explains how to monitor and respond to system memory pressure, enabling your application to adapt its behavior and prevent out-of-memory conditions.","ref":"memory_pressure.html"},{"type":"extras","title":"Prerequisites - Memory Pressure","doc":"Before reading this guide, you should understand:\n- Basic Erlang/OTP memory concepts (processes, ETS, binaries)\n- Subscription patterns ([Subscriptions Guide](subscriptions.md))\n- Why backpressure matters in event-driven systems","ref":"memory_pressure.html#prerequisites"},{"type":"extras","title":"The Problem: Unbounded Memory Growth - Memory Pressure","doc":"Event-driven systems can experience memory pressure from many sources:\n\n- **Slow consumers** - Events queue up faster than they're processed\n- **Large projections** - Read models grow beyond available memory\n- **Binary accumulation** - Large event payloads aren't garbage collected\n- **Cache bloat** - Unbounded caches grow indefinitely\n\nWithout monitoring, these issues lead to OOM crashes, taking down your entire node.","ref":"memory_pressure.html#the-problem-unbounded-memory-growth"},{"type":"extras","title":"The Solution: Adaptive Behavior - Memory Pressure","doc":"Memory pressure monitoring enables:\n\n1. **Early warning** - Detect problems before they crash the system\n2. **Graceful degradation** - Reduce load when memory is scarce\n3. **Automatic recovery** - Resume normal operation when pressure eases\n\n```\nMemory Usage:\n100% \n                                                    CRITICAL  \n 85%                              \n                                                  \n 70%                              \n                           ELEVATED        \n                                                         \n  0%                                NORMAL                       \n     \n      Time \n```\n\n---","ref":"memory_pressure.html#the-solution-adaptive-behavior"},{"type":"extras","title":"Where Does This Code Run? - Memory Pressure","doc":"| Operation | Location | Module |\n|-----------|----------|--------|\n| Query pressure level | Your Application | `esdb_gater_api` |\n| Monitor memory | reckon-db Server | `reckon_db_memory` |\n| Emit telemetry | reckon-db Server | `reckon_db_telemetry` |\n| Adaptive behavior | Your Application | Your handlers |\n\n---","ref":"memory_pressure.html#where-does-this-code-run"},{"type":"extras","title":"API Reference - Memory Pressure","doc":"","ref":"memory_pressure.html#api-reference"},{"type":"extras","title":"Get Memory Level - Memory Pressure","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Check current memory pressure level\n%%--------------------------------------------------------------------\n\n{ok, Level} = esdb_gater_api:get_memory_level(my_store).\n%% => {ok, normal}\n%% => {ok, elevated}\n%% => {ok, critical}\n```","ref":"memory_pressure.html#get-memory-level"},{"type":"extras","title":"Get Detailed Memory Stats - Memory Pressure","doc":"```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Get detailed memory breakdown\n%%--------------------------------------------------------------------\n\n{ok, Stats} = esdb_gater_api:get_memory_stats(my_store).\n%% => #{\n%%     level => normal,\n%%     used => 4294967296,        %% 4 GB total used\n%%     total => 17179869184,      %% 16 GB total available\n%%     percentage => 25.0,        %% 25% used\n%%     processes => 1073741824,   %% 1 GB in Erlang processes\n%%     binary => 536870912,       %% 512 MB in binaries\n%%     ets => 268435456,          %% 256 MB in ETS tables\n%%     atom => 1048576            %% 1 MB in atoms\n%% }\n```\n\n---","ref":"memory_pressure.html#get-detailed-memory-stats"},{"type":"extras","title":"Pressure Levels - Memory Pressure","doc":"| Level | Threshold | Description | Recommended Action |\n|-------|-----------|-------------|-------------------|\n| `normal` | < 70% | System operating normally | No action needed |\n| `elevated` | 70-85% | Memory usage is high | Reduce batch sizes, evict caches |\n| `critical` | > 85% | Memory pressure severe | Pause subscriptions, aggressive cleanup |\n\n---","ref":"memory_pressure.html#pressure-levels"},{"type":"extras","title":"Configuration - Memory Pressure","doc":"Configure thresholds in `sys.config`:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This configuration lives in: sys.config (deployment)\n%% Purpose: Set memory pressure thresholds\n%%--------------------------------------------------------------------\n\n[{reckon_db, [\n    {memory_pressure, [\n        {elevated_threshold, 0.70},   %% 70% = elevated\n        {critical_threshold, 0.85},   %% 85% = critical\n        {check_interval, 10000}       %% Check every 10 seconds\n    ]}\n]}].\n```\n\n---","ref":"memory_pressure.html#configuration"},{"type":"extras","title":"Use Cases - Memory Pressure","doc":"","ref":"memory_pressure.html#use-cases"},{"type":"extras","title":"1. Adaptive Batch Sizes - Memory Pressure","doc":"Reduce processing load when memory is constrained:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Adjust batch sizes based on memory pressure\n%%--------------------------------------------------------------------\n\n-module(adaptive_processor).\n\nget_batch_size(StoreId) ->\n    {ok, Level} = esdb_gater_api:get_memory_level(StoreId),\n    case Level of\n        normal -> 1000;    %% Full speed\n        elevated -> 500;   %% Half speed\n        critical -> 100    %% Minimal processing\n    end.\n\nprocess_events(StoreId, StreamId) ->\n    BatchSize = get_batch_size(StoreId),\n    {ok, Events} = esdb_gater_api:stream_forward(StoreId, StreamId, 0, BatchSize),\n    lists:foreach(fun process_event/1, Events).\n```","ref":"memory_pressure.html#1-adaptive-batch-sizes"},{"type":"extras","title":"2. Memory-Aware Caching - Memory Pressure","doc":"Evict caches when memory pressure rises:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Clear caches based on memory pressure\n%%--------------------------------------------------------------------\n\n-module(cache_manager).\n\nhandle_memory_pressure(normal) ->\n    ok;  %% Keep caches\n\nhandle_memory_pressure(elevated) ->\n    %% Evict 50% of cache\n    cache:evict_percentage(50),\n    logger:info(\"Evicted 50% of cache due to elevated memory pressure\");\n\nhandle_memory_pressure(critical) ->\n    %% Clear entire cache\n    cache:clear(),\n    logger:warning(\"Cleared cache due to critical memory pressure\").\n```","ref":"memory_pressure.html#2-memory-aware-caching"},{"type":"extras","title":"3. Gating Expensive Operations - Memory Pressure","doc":"Reject expensive operations when memory is scarce:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION\n%% Purpose: Refuse expensive work during memory pressure\n%%--------------------------------------------------------------------\n\n-module(resource_guard).\n\nmaybe_run_expensive_operation(StoreId, Fun) ->\n    {ok, Level} = esdb_gater_api:get_memory_level(StoreId),\n    case Level of\n        critical ->\n            {error, memory_pressure};\n        _ ->\n            Fun()\n    end.\n\n%% Usage\nhandle_request(Req) ->\n    case maybe_run_expensive_operation(my_store, fun() ->\n        process_large_report(Req)\n    end) of\n        {error, memory_pressure} ->\n            {503, <<\"Service temporarily unavailable due to memory pressure\">>};\n        Result ->\n            Result\n    end.\n```","ref":"memory_pressure.html#3-gating-expensive-operations"},{"type":"extras","title":"4. Process Manager Deferral - Memory Pressure","doc":"Pause saga processing during pressure:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (process manager)\n%% Purpose: Defer event processing when memory is critical\n%%--------------------------------------------------------------------\n\n-module(order_saga).\n\nhandle_event(Event, State) ->\n    {ok, Level} = esdb_gater_api:get_memory_level(State#state.store_id),\n    case Level of\n        critical ->\n            %% Defer processing until memory recovers\n            logger:info(\"Deferring event due to memory pressure\"),\n            {defer, Event, State};\n        _ ->\n            do_handle_event(Event, State)\n    end.\n```\n\n---","ref":"memory_pressure.html#4-process-manager-deferral"},{"type":"extras","title":"Monitoring with Telemetry - Memory Pressure","doc":"Memory pressure changes emit telemetry events:\n\n```erlang\n%%--------------------------------------------------------------------\n%% This code runs in: YOUR APPLICATION (startup)\n%% Purpose: Alert on memory pressure changes\n%%--------------------------------------------------------------------\n\nsetup_memory_alerts() ->\n    telemetry:attach(\n        <<\"memory-pressure-handler\">>,\n        [reckon_db, memory, pressure_changed],\n        fun handle_pressure_change/4,\n        #{}\n    ).\n\nhandle_pressure_change(\n    _Event,\n    _Measurements,\n    #{old_level := Old, new_level := New},\n    _Config\n) ->\n    case New of\n        critical ->\n            send_alert(\"CRITICAL: Memory pressure is severe\"),\n            logger:error(\"Memory pressure: ~p -> ~p\", [Old, New]);\n        elevated ->\n            logger:warning(\"Memory pressure: ~p -> ~p\", [Old, New]);\n        normal ->\n            logger:info(\"Memory pressure returned to normal\")\n    end.\n```\n\n---","ref":"memory_pressure.html#monitoring-with-telemetry"},{"type":"extras","title":"Common Pitfalls - Memory Pressure","doc":"","ref":"memory_pressure.html#common-pitfalls"},{"type":"extras","title":"1. Ignoring Memory Levels - Memory Pressure","doc":"```erlang\n%% BAD: Processing without checking memory\nprocess_all_events(StoreId) ->\n    {ok, Events} = esdb_gater_api:stream_forward(StoreId, Stream, 0, 10000),\n    lists:foreach(fun process/1, Events).  %% May OOM!\n\n%% GOOD: Respect memory pressure\nprocess_all_events(StoreId) ->\n    {ok, Level} = esdb_gater_api:get_memory_level(StoreId),\n    case Level of\n        critical -> {error, memory_pressure};\n        _ ->\n            BatchSize = get_batch_size(Level),\n            {ok, Events} = esdb_gater_api:stream_forward(StoreId, Stream, 0, BatchSize),\n            lists:foreach(fun process/1, Events)\n    end.\n```","ref":"memory_pressure.html#1-ignoring-memory-levels"},{"type":"extras","title":"2. Polling Too Frequently - Memory Pressure","doc":"```erlang\n%% BAD: Checking memory on every operation\nprocess_event(Event) ->\n    {ok, _} = esdb_gater_api:get_memory_level(Store),  %% Every event!\n    do_process(Event).\n\n%% GOOD: Check periodically or rely on telemetry\n-record(state, {memory_level = normal}).\n\ninit() ->\n    telemetry:attach(..., fun update_cached_level/4, ...),\n    {ok, #state{}}.\n\nprocess_event(Event, #state{memory_level = critical}) ->\n    {defer, Event};\nprocess_event(Event, State) ->\n    do_process(Event),\n    {ok, State}.\n```","ref":"memory_pressure.html#2-polling-too-frequently"},{"type":"extras","title":"3. Not Recovering from Pressure - Memory Pressure","doc":"```erlang\n%% BAD: Entering degraded mode permanently\nhandle_pressure(critical, State) ->\n    State#state{degraded = true}.  %% Never recovers!\n\n%% GOOD: State based on current level\nhandle_event(Event, State) ->\n    {ok, Level} = esdb_gater_api:get_memory_level(Store),\n    case Level of\n        critical -> {defer, Event, State};\n        elevated -> process_slowly(Event, State);\n        normal -> process_normally(Event, State)\n    end.\n```\n\n---","ref":"memory_pressure.html#3-not-recovering-from-pressure"},{"type":"extras","title":"When NOT to Query Memory Pressure - Memory Pressure","doc":"- **On every event** - Too expensive; use cached level or telemetry\n- **In tight loops** - Check once at start of batch, not per-item\n- **For simple operations** - Only matters for memory-intensive work\n\n---","ref":"memory_pressure.html#when-not-to-query-memory-pressure"},{"type":"extras","title":"Best Practices - Memory Pressure","doc":"1. **Monitor pressure levels** - Alert on elevated/critical via telemetry\n2. **Implement adaptive behavior** - Reduce load automatically when pressure rises\n3. **Test under pressure** - Verify system handles high memory gracefully\n4. **Set appropriate thresholds** - Tune based on your hardware and workload\n5. **Use backpressure** - Slow down producers instead of dropping work\n6. **Cache the level** - Don't query on every operation\n\n---","ref":"memory_pressure.html#best-practices"},{"type":"extras","title":"Related Guides - Memory Pressure","doc":"- [Subscriptions](subscriptions.md) - Backpressure in subscriptions\n- [Stream Links](stream_links.md) - Links adapt to memory pressure\n- [Scavenging](scavenging.md) - Free memory by removing old events","ref":"memory_pressure.html#related-guides"}],"proglang":"erlang","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}